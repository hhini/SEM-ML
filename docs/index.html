<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>SEM + ML 实际项目论文复现</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-1d4f84655f446305ac42a8f1abcf7405.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>


</head>

<body class="quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    <div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="index.docx"><i class="bi bi-file-word"></i>MS Word</a></li></ul></div></div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">SEM + ML 实际项目论文复现</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">JAYZJAYZ </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            GAN NAN medical university
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  


</header>


<section id="sem加ml分析" class="level1">
<h1>SEM加ML分析 🫥</h1>
<hr>
<p><strong><em>要具体知道为什么要结合，可以参考文献 <a href="https://link.springer.com/article/10.1007/s40747-021-00503-w">混合人工神经网络与结构方程模型技术：综述</a>Hybrid artificial neural network and structural equation modelling techniques: a survey</em></strong></p>
<section id="为什么要结合机器学习ml与结构方程模型sem" class="level2">
<h2 class="anchored" data-anchor-id="为什么要结合机器学习ml与结构方程模型sem">为什么要结合机器学习（ML）与结构方程模型（SEM）</h2>
<section id="理论与实践的融合sem-ml-的优势" class="level3">
<h3 class="anchored" data-anchor-id="理论与实践的融合sem-ml-的优势">✨ 理论与实践的融合：SEM + ML 的优势</h3>
<p>结构方程模型（SEM）是一种强大的因果建模工具，能够同时处理测量模型（潜变量）和路径模型（变量间关系）。但在实际研究中，尤其是面对高维数据(就是变量多)、复杂变量结构或非线性关系时，SEM也面临挑战：</p>
<ul>
<li><p><strong>变量筛选困难</strong>：传统SEM依赖理论假设，变量选择主观性强(一般要参考社会科学文献，并且进行假设，麻了)；</p></li>
<li><p><strong>模型拟合受限</strong>：当变量数量多、关系复杂时，SEM模型容易过拟合或拟合不佳(过拟合和欠拟合)；</p></li>
<li><p><strong>预测能力有限</strong>：SEM更偏向解释性而非预测性。</p></li>
</ul>
<p>而机器学习（ML）正好可以补足这些短板：</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>功能</th>
<th>SEM</th>
<th>ML</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>因果推理</td>
<td>✅ 强</td>
<td>❌ 弱（但可辅助）</td>
</tr>
<tr class="even">
<td>潜变量建模</td>
<td>✅ 支持</td>
<td>❌ 不直接支持</td>
</tr>
<tr class="odd">
<td>特征筛选</td>
<td>❌ 依赖理论</td>
<td>✅ 数据驱动</td>
</tr>
<tr class="even">
<td>非线性建模</td>
<td>❌ 有限</td>
<td>✅ 强大</td>
</tr>
<tr class="odd">
<td>预测能力</td>
<td>❌ 弱</td>
<td>✅ 强</td>
</tr>
</tbody>
</table>
<p>因此，将ML与SEM结合，可以实现：</p>
<ul>
<li><p><strong>数据驱动的变量筛选</strong>（如用随机森林或SHAP值找出最重要的预测因子(一般来说如果变量较多的时候，一般是不降维的，而是筛选变量的）；</p></li>
<li><p><strong>提升模型解释力与预测力</strong>（先用ML找出<strong>关键变量</strong>，再用SEM建模路径）；</p></li>
<li><p><strong>增强模型稳健性</strong>（ML可用于<strong>验证</strong>SEM模型的泛化能力）；</p></li>
<li><p><strong>提高研究影响力</strong>（结合方法更前沿，易发表在高影响因子期刊）。</p></li>
</ul>
</section>
<section id="文献支持结合ml与sem的研究越来越多影响因子也在上升" class="level3">
<h3 class="anchored" data-anchor-id="文献支持结合ml与sem的研究越来越多影响因子也在上升">📈 文献支持：结合ML与SEM的研究越来越多，影响因子也在上升</h3>
<p>以下是提供的几篇代表性文献，展示了ML+SEM的实际应用与发表潜力：</p>
<ol type="1">
<li><p>✅ <strong>复现的论文</strong>： PMC12236327</p>
<ul>
<li><p>结合随机森林与SEM，识别影响精神分裂症患者主观幸福感的关键因素。</p></li>
<li><p>通过ML筛选变量，再用lavaan构建路径模型，实现因果解释与预测并重。</p></li>
<li><p>发表在《Translational Psychiatry》，IF ≈ 7.9。</p></li>
</ul></li>
<li><p>📱 <strong>智能穿戴设备采纳研究</strong>： Bou Nassif et al.&nbsp;(2022)</p>
<ul>
<li><p>使用PLS-SEM与ML对智能手表采纳意图进行建模。</p></li>
<li><p>ML揭示“用户满意度”是最关键预测因子，SEM验证其路径关系。</p></li>
<li><p>发表在《Heliyon》，IF ≈ 4.0。</p></li>
</ul></li>
<li><p>🧠 <strong>消费者心理与行为研究</strong>： ScienceDirect 2023论文</p>
<ul>
<li><p>用ML筛选影响消费者信任的变量，再用SEM建模信任形成机制。</p></li>
<li><p>发表在《Journal of Business Research》，IF ≈ 10.0。</p></li>
</ul></li>
<li><p>🧬 <strong>健康行为预测研究</strong>： ScienceDirect 2024论文</p>
<ul>
<li><p>结合ML与SEM预测健康行为采纳，强调数据驱动与理论建模的融合。</p></li>
<li><p>发表在《Preventive Medicine Reports》，IF ≈ 3.5。</p></li>
</ul></li>
</ol>
<hr>
</section>
</section>
<section id="什么是机器学习" class="level2">
<h2 class="anchored" data-anchor-id="什么是机器学习">什么是机器学习🫤</h2>
<p>在正式进入机器学习（Machine Learning, ML）＋结构方程模型（SEM）的整合应用之前，首先要让大家对“机器学习”这个概念有一个直观的理解。不必过分纠结复杂的数学公式，而要抓住它的核心思想和研究流程。</p>
<section id="机器学习的定义" class="level3">
<h3 class="anchored" data-anchor-id="机器学习的定义">2.1 机器学习的定义🤤</h3>
<p>机器学习是一种<strong><em>让计算机通过“样本数据”自行发现规律</em></strong>，<strong><em>并将这些规律用于“预测”或“决策”的技术。</em></strong><br>
- 它不像传统统计学那样强调整体假设检验和参数估计，更注重“从数据中自动学习”。<br>
- ML 旨在用已有数据训练一个模型，让模型在新数据上也能表现出良好的预测或分类能力。</p>
<p><strong><em>这也让机器学习无法用数学公式和因果关系来知道电脑是怎么想的，形成了所谓的黑匣子，解释性太差，但是用来预测就没毛病</em></strong></p>
</section>
<section id="ml-与传统统计方法的差异" class="level3">
<h3 class="anchored" data-anchor-id="ml-与传统统计方法的差异">2.2 ML 与传统统计方法的差异🌮</h3>
<ul>
<li>目标不同
<ul>
<li>统计学：偏重解释性，解析变量间的因果或关联；<br>
</li>
<li>机器学习：偏重预测性，追求模型的泛化能力，即给我数据我可以预测出大概的，符合之前数据的答案。</li>
</ul></li>
<li>模型假设
<ul>
<li>统计模型：通常要求满足正态性、线性关系等严格假设；<br>
</li>
<li>ML 模型：对数据分布和关系的假设更弱，<strong><em>可以处理非线性、高维度数据</em></strong>。</li>
</ul></li>
<li>关注点
<ul>
<li>统计方法：估计参数、显著性检验、置信区间；<br>
</li>
<li>ML 方法：<strong><em>模型选择、交叉验证、过拟合控制、预测误差</em></strong>。</li>
</ul></li>
</ul>
</section>
<section id="机器学习的主要类型" class="level3">
<h3 class="anchored" data-anchor-id="机器学习的主要类型">2.3 机器学习的主要类型🤖</h3>
<ol type="1">
<li><strong>监督学习（Supervised Learning）</strong>
<ul>
<li>有“标签”的数据（例如：患者有/无压力性损伤）。<br>
</li>
<li>常见算法：逻辑回归、决策树、随机森林、支持向量机、神经网络等。<br>
</li>
<li>核心任务：分类（Classification）和回归（Regression）。</li>
</ul></li>
<li><strong>无监督学习（Unsupervised Learning）</strong>
<ul>
<li>无标签数据。<br>
</li>
<li>常见算法：聚类（K-means、层次聚类）、降维（PCA、t-SNE）。<br>
</li>
<li>核心任务：发现数据的内在结构、分群、特征降维。</li>
</ul></li>
<li><strong>强化学习（Reinforcement Learning）</strong>
<ul>
<li>通过“试错”与环境互动来学习最优策略。<br>
</li>
<li>在护理研究中应用相对少，可用于优化护理路径或资源调度。</li>
</ul></li>
</ol>
</section>
<section id="机器学习研究流程" class="level3">
<h3 class="anchored" data-anchor-id="机器学习研究流程">2.4 机器学习研究流程🛫</h3>
<ol type="1">
<li><strong>数据准备与清洗</strong>
<ul>
<li>汇总临床指标、问卷量表、电子健康记录等；<br>
</li>
<li>处理缺失值、异常值、分类变量编码。</li>
</ul></li>
<li><strong>特征工程</strong>
<ul>
<li>选择或构造与研究目标最相关的变量（特征）即挑选重要的特征变量，过滤不需要的变量；<br>
</li>
<li>归一化、标准化、one-hot 编码(独热编码)等。</li>
</ul></li>
<li><strong>模型训练与优化</strong>
<ul>
<li>在“训练集”上训练模型；<br>
</li>
<li>通过交叉验证（Cross-Validation）选择超参数，<strong>防止过拟合</strong>(过拟合即是对模型来说，学习太多不重要的特征，比如我训练了一个识别学长还是学姐的模型，但是模型学习到了几个女装的学长，本来女装这是几个人的特殊癖好，但是模型认为女装的都是学长，这扯不扯）。</li>
</ul></li>
<li><strong>模型评估</strong>
<ul>
<li><strong><em>在“测试集”或“留出数据”上评估预测性能</em></strong>，这也是为什么机器学习都要分成训练集和验证集，要么7/3,要么8/2等等（千万别耍小聪明，觉得数据不够多，还要拆分，耍滑头把所有数据都拿去训练，然后再拿其中一部分来预测，因为模型有记忆的，你预测训练过的数据，肯定准确率是百分百，就好像你明明知道明天的天气，那为什么要根据之前的数据推测呢）（如 AUC、准确率、RMSE）；<br>
</li>
<li>比较不同算法的优劣。</li>
</ul></li>
<li><strong>模型解释与应用</strong>
<ul>
<li><p>使用 SHAP、LIME 等方法<strong>解释模型</strong></p>
<p>它们是两种常用的“模型解释工具”，可以告诉我们：<strong>哪些变量对模型预测最重要，以及它们的影响方向</strong></p></li>
</ul></li>
</ol>
<hr>
</section>
</section>
</section>
<section id="复现一篇论文" class="level1">
<h1>复现一篇论文🤖</h1>
<p><strong><code>最好学习的方法就是看相关论文，然后学习论文知识，然后复现学习，所以啥也不说了，直接真刀真枪开干就完了</code></strong></p>
<section id="replicating-research-on-subjective-well-being-in-schizophrenia-a-guide-to-generating-synthetic-data-for-sem-and-machine-learning-精神分裂症患者主观幸福感研究sem-和机器学习合成数据生成指南" class="level4">
<h4 class="anchored" data-anchor-id="replicating-research-on-subjective-well-being-in-schizophrenia-a-guide-to-generating-synthetic-data-for-sem-and-machine-learning-精神分裂症患者主观幸福感研究sem-和机器学习合成数据生成指南">Replicating Research on Subjective Well-Being in Schizophrenia: A Guide to Generating Synthetic Data for SEM and Machine Learning 精神分裂症患者主观幸福感研究：SEM 和机器学习合成数据生成指南</h4>
</section>
<section id="论文链接-2024-sep-7-51411181133.-doi-10.1093schbulsbae156---if7.9我也不知道为什么这种文章有7分做生信累死累活还拿不到5分吐槽一下麻了" class="level4">
<h4 class="anchored" data-anchor-id="论文链接-2024-sep-7-51411181133.-doi-10.1093schbulsbae156---if7.9我也不知道为什么这种文章有7分做生信累死累活还拿不到5分吐槽一下麻了"><a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC12236327/#s5">论文链接</a> 2024 Sep 7 ; 51(4):1118–1133. doi: 10.1093/schbul/sbae156 - IF=7.9(我也不知道为什么这种文章有7分，做生信累死累活还拿不到5分，吐槽一下，麻了🥶）</h4>
<p><strong><em>！现在我不以社会科学的角度解析这篇文章，只用统计学和代码来解析如何处理</em></strong></p>
<p>因为我现在没有相关的数据，所以我只能用代码模拟和文章差不多的数据</p>
<ul>
<li><p><strong>表 1：机器学习模型中包含的独立变量列表：</strong> 该表概述了分析中使用的所有变量，包括社会人口因素（年龄、性别、教育、职业）、疾病相关因素（疾病持续时间）和各种临床测量。</p></li>
<li><p><strong>表 2：样本特征：</strong>提供了 637 名患者原始数据集中变量的描述性统计数据。它包括连续变量的平均值、标准差和范围，以及分类变量的频率。</p></li>
<li><p><strong>图 3：网络模型和中心性指标：</strong>展示了不同变量之间的相关性。连接及其粗细表示关系的强度，这应该反映在合成数据的相关矩阵中。</p></li>
<li><p><strong>图 4：结构方程模型（SEM）分析：</strong> 该图比网络分析更进一步，揭示了变量之间的因果路径和效应方向。路径系数量化了这些关系的强度和方向。</p></li>
</ul>
</section>
<section id="使用-python-生成合成数据" class="level4">
<h4 class="anchored" data-anchor-id="使用-python-生成合成数据">使用 Python 生成合成数据</h4>
<p>以下 Python 代码演示了如何生成一个与论文中描述的特征近似的合成数据集。此代码使用 numpy 和 pandas 库创建一个数据框，其中包含与原始研究中的变量具有相似统计特性和相关性的变量。变量不用Chinese</p>
<div id="59340f4d" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 导入所需的库</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 导入所需的库</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> truncnorm</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1. 定义样本量 ---</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>n_patients <span class="op">=</span> <span class="dv">637</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 2. 基于SEM和网络分析生成核心相关数据 ---</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>correlation_matrix <span class="op">=</span> np.array([</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># SWB,   OCS,   Som,   Cog,   Dep,   Neg,   Pos,   PSP</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">1.00</span>, <span class="op">-</span><span class="fl">0.59</span>, <span class="op">-</span><span class="fl">0.40</span>, <span class="op">-</span><span class="fl">0.20</span>, <span class="op">-</span><span class="fl">0.35</span>, <span class="op">-</span><span class="fl">0.25</span>, <span class="op">-</span><span class="fl">0.15</span>,  <span class="fl">0.30</span>],</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="fl">0.59</span>,  <span class="fl">1.00</span>,  <span class="fl">0.70</span>,  <span class="fl">0.30</span>,  <span class="fl">0.40</span>,  <span class="fl">0.20</span>,  <span class="fl">0.18</span>, <span class="op">-</span><span class="fl">0.25</span>],</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="fl">0.40</span>,  <span class="fl">0.70</span>,  <span class="fl">1.00</span>,  <span class="fl">0.25</span>,  <span class="fl">0.35</span>,  <span class="fl">0.15</span>,  <span class="fl">0.10</span>, <span class="op">-</span><span class="fl">0.20</span>],</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="fl">0.20</span>,  <span class="fl">0.30</span>,  <span class="fl">0.25</span>,  <span class="fl">1.00</span>,  <span class="fl">0.26</span>,  <span class="fl">0.48</span>,  <span class="fl">0.36</span>, <span class="op">-</span><span class="fl">0.40</span>],</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="fl">0.35</span>,  <span class="fl">0.40</span>,  <span class="fl">0.35</span>,  <span class="fl">0.26</span>,  <span class="fl">1.00</span>,  <span class="fl">0.35</span>,  <span class="fl">0.24</span>, <span class="op">-</span><span class="fl">0.50</span>],</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="fl">0.25</span>,  <span class="fl">0.20</span>,  <span class="fl">0.15</span>,  <span class="fl">0.48</span>,  <span class="fl">0.35</span>,  <span class="fl">1.00</span>,  <span class="fl">0.22</span>, <span class="op">-</span><span class="fl">0.60</span>],</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="fl">0.15</span>,  <span class="fl">0.18</span>,  <span class="fl">0.10</span>,  <span class="fl">0.36</span>,  <span class="fl">0.24</span>,  <span class="fl">0.22</span>,  <span class="fl">1.00</span>, <span class="op">-</span><span class="fl">0.30</span>],</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    [ <span class="fl">0.30</span>, <span class="op">-</span><span class="fl">0.25</span>, <span class="op">-</span><span class="fl">0.20</span>, <span class="op">-</span><span class="fl">0.40</span>, <span class="op">-</span><span class="fl">0.50</span>, <span class="op">-</span><span class="fl">0.60</span>, <span class="op">-</span><span class="fl">0.30</span>,  <span class="fl">1.00</span>]</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>mean <span class="op">=</span> np.zeros(correlation_matrix.shape[<span class="dv">0</span>])</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>correlated_data <span class="op">=</span> np.random.multivariate_normal(mean, correlation_matrix, size<span class="op">=</span>n_patients)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 缩放和转换数据以匹配论文表2中的统计特征 ---</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> scale_variable(data_column, mean, std, min_val, max_val):</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    scaled <span class="op">=</span> data_column <span class="op">*</span> std <span class="op">+</span> mean</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.clip(scaled, min_val, max_val)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>cgi_pos <span class="op">=</span> scale_variable(correlated_data[:, <span class="dv">6</span>], <span class="fl">3.7</span>, <span class="fl">1.4</span>, <span class="dv">1</span>, <span class="dv">7</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>cgi_neg <span class="op">=</span> scale_variable(correlated_data[:, <span class="dv">5</span>], <span class="fl">3.3</span>, <span class="fl">1.2</span>, <span class="dv">1</span>, <span class="dv">7</span>)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>cgi_dep <span class="op">=</span> scale_variable(correlated_data[:, <span class="dv">4</span>], <span class="fl">2.6</span>, <span class="fl">1.2</span>, <span class="dv">1</span>, <span class="dv">6</span>)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>cgi_cog <span class="op">=</span> scale_variable(correlated_data[:, <span class="dv">3</span>], <span class="fl">3.1</span>, <span class="fl">1.1</span>, <span class="dv">1</span>, <span class="dv">6</span>)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>scl_som <span class="op">=</span> scale_variable(correlated_data[:, <span class="dv">2</span>], <span class="fl">21.3</span>, <span class="fl">8.7</span>, <span class="dv">12</span>, <span class="dv">58</span>)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>scl_ocs <span class="op">=</span> scale_variable(correlated_data[:, <span class="dv">1</span>], <span class="fl">22.4</span>, <span class="fl">8.3</span>, <span class="dv">10</span>, <span class="dv">50</span>)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>swn_total <span class="op">=</span> scale_variable(correlated_data[:, <span class="dv">0</span>], <span class="fl">73.5</span>, <span class="fl">17.6</span>, <span class="dv">24</span>, <span class="dv">120</span>)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>psp_total <span class="op">=</span> scale_variable(correlated_data[:, <span class="dv">7</span>], <span class="fl">55.9</span>, <span class="fl">14.8</span>, <span class="dv">10</span>, <span class="dv">90</span>)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>diepss_severity <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">4</span>, n_patients)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>diepss_severity <span class="op">=</span> np.clip(diepss_severity, <span class="dv">0</span>, <span class="dv">4</span>)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>diepss_severity_mean <span class="op">=</span> np.mean(diepss_severity)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>diepss_severity <span class="op">=</span> (diepss_severity <span class="op">-</span> diepss_severity_mean) <span class="op">*</span> (<span class="fl">0.8</span> <span class="op">/</span> np.std(diepss_severity)) <span class="op">+</span> <span class="fl">0.6</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>diepss_severity <span class="op">=</span> np.clip(diepss_severity, <span class="dv">0</span>, <span class="dv">4</span>)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 4. 生成社会人口统计学及其他变量 ---</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>age_mean, age_std, age_min, age_max <span class="op">=</span> <span class="fl">35.7</span>, <span class="fl">10.5</span>, <span class="dv">18</span>, <span class="dv">64</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>age <span class="op">=</span> truncnorm.rvs((age_min <span class="op">-</span> age_mean) <span class="op">/</span> age_std, (age_max <span class="op">-</span> age_mean) <span class="op">/</span> age_std, loc<span class="op">=</span>age_mean, scale<span class="op">=</span>age_std, size<span class="op">=</span>n_patients)</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>sex <span class="op">=</span> np.random.choice([<span class="dv">1</span>, <span class="dv">0</span>], size<span class="op">=</span>n_patients, p<span class="op">=</span>[<span class="fl">0.529</span>, <span class="fl">0.471</span>])</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>education <span class="op">=</span> np.random.choice([<span class="st">'Less than 12 years'</span>, <span class="st">'High school'</span>, <span class="st">'College or graduate'</span>], size<span class="op">=</span>n_patients, p<span class="op">=</span>[<span class="fl">0.171</span>, <span class="fl">0.413</span>, <span class="fl">0.416</span>])</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>occupation <span class="op">=</span> np.random.choice([<span class="dv">1</span>, <span class="dv">0</span>], size<span class="op">=</span>n_patients, p<span class="op">=</span>[<span class="fl">0.174</span>, <span class="fl">0.826</span>])</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>illness_duration_mean, illness_duration_std, illness_duration_min, illness_duration_max <span class="op">=</span> <span class="fl">9.1</span>, <span class="fl">8.1</span>, <span class="dv">0</span>, <span class="dv">44</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>illness_duration <span class="op">=</span> truncnorm.rvs((illness_duration_min <span class="op">-</span> illness_duration_mean) <span class="op">/</span> illness_duration_std, (illness_duration_max <span class="op">-</span> illness_duration_mean) <span class="op">/</span> illness_duration_std, loc<span class="op">=</span>illness_duration_mean, scale<span class="op">=</span>illness_duration_std, size<span class="op">=</span>n_patients)</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>obesity <span class="op">=</span> np.random.choice([<span class="dv">1</span>, <span class="dv">0</span>], size<span class="op">=</span>n_patients, p<span class="op">=</span>[<span class="fl">0.468</span>, <span class="fl">0.532</span>])</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>hypertension <span class="op">=</span> np.random.choice([<span class="dv">1</span>, <span class="dv">0</span>], size<span class="op">=</span>n_patients, p<span class="op">=</span>[<span class="fl">0.273</span>, <span class="fl">0.727</span>])</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>diabetes <span class="op">=</span> np.random.choice([<span class="dv">1</span>, <span class="dv">0</span>], size<span class="op">=</span>n_patients, p<span class="op">=</span>[<span class="fl">0.154</span>, <span class="fl">0.846</span>])</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 5. 组合成 Pandas DataFrame ---</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>synthetic_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Age'</span>: age.<span class="bu">round</span>(<span class="dv">1</span>),</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Sex_Female'</span>: sex,</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Education'</span>: education,</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Occupation_Employed'</span>: occupation,</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Duration_of_Illness'</span>: illness_duration.<span class="bu">round</span>(<span class="dv">1</span>),</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Obesity'</span>: obesity,</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Hypertension'</span>: hypertension,</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Diabetes'</span>: diabetes,</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    <span class="st">'CGI_Positive'</span>: cgi_pos.<span class="bu">round</span>(<span class="dv">1</span>),</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>    <span class="st">'CGI_Negative'</span>: cgi_neg.<span class="bu">round</span>(<span class="dv">1</span>),</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    <span class="st">'CGI_Depressive'</span>: cgi_dep.<span class="bu">round</span>(<span class="dv">1</span>),</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>    <span class="st">'CGI_Cognitive'</span>: cgi_cog.<span class="bu">round</span>(<span class="dv">1</span>),</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    <span class="st">'SCL90R_Somatization'</span>: scl_som.<span class="bu">round</span>(<span class="dv">1</span>),</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    <span class="st">'SCL90R_OCS'</span>: scl_ocs.<span class="bu">round</span>(<span class="dv">1</span>),</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="st">'SWN_Total_Score'</span>: swn_total.<span class="bu">round</span>(<span class="dv">1</span>),</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>    <span class="st">'DIEPSS_Overall_Severity'</span>: diepss_severity.<span class="bu">round</span>(<span class="dv">1</span>),</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>    <span class="st">'PSP_Total_Score'</span>: psp_total.<span class="bu">round</span>(<span class="dv">1</span>)</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 6. 将数据框 (DataFrame) 保存为 CSV 文件 ---</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a><span class="co"># !!! 重要提示: 请将下面的路径修改为您希望保存文件的实际位置 !!!</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a><span class="co"># 例如 Windows: "C:/Users/用户名/Documents/synthetic_data.csv"</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a><span class="co"># 例如 macOS: "/Users/用户名/Documents/synthetic_data.csv"</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> <span class="st">"./synthetic_schizophrenia_data.csv"</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a><span class="co"># 使用 to_csv() 函数来保存数据</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a><span class="co"># 参数 index=False 的意思是，数据框的行索引 (0, 1, 2, ...) 不会被写入到 CSV 文件中</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>synthetic_df.to_csv(file_path, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(synthetic_df.head(<span class="dv">10</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>    Age  Sex_Female            Education  Occupation_Employed  \
0  21.5           1          High school                    0   
1  29.3           0          High school                    0   
2  48.7           0  College or graduate                    0   
3  18.9           1          High school                    0   
4  28.2           0          High school                    1   
5  53.8           1   Less than 12 years                    1   
6  39.2           0          High school                    0   
7  30.0           1          High school                    1   
8  22.8           0          High school                    1   
9  20.4           1          High school                    0   

   Duration_of_Illness  Obesity  Hypertension  Diabetes  CGI_Positive  \
0                 13.7        0             0         0           2.7   
1                 16.2        0             0         0           3.3   
2                 11.0        1             0         1           4.7   
3                 12.1        1             0         0           4.0   
4                  5.0        1             1         0           3.5   
5                  6.6        1             0         0           3.9   
6                  4.2        0             1         0           4.8   
7                  5.9        1             0         0           2.3   
8                  5.4        0             0         0           3.0   
9                 10.8        1             0         0           5.1   

   CGI_Negative  CGI_Depressive  CGI_Cognitive  SCL90R_Somatization  \
0           5.1             2.8            4.0                 23.6   
1           1.1             2.7            3.5                 17.5   
2           1.7             1.8            1.8                 14.4   
3           2.1             1.8            3.5                 17.2   
4           2.8             4.0            3.5                 12.0   
5           3.1             4.1            3.9                 26.0   
6           5.1             3.4            3.3                 14.7   
7           2.6             1.6            3.4                 20.2   
8           3.5             2.8            3.8                 28.0   
9           1.6             1.4            4.0                 36.0   

   SCL90R_OCS  SWN_Total_Score  DIEPSS_Overall_Severity  PSP_Total_Score  
0        27.8             75.3                      0.0             59.8  
1        19.3             65.1                      1.1             61.6  
2        12.9             61.6                      1.9             71.8  
3        26.7             92.3                      0.0             64.4  
4        15.6             69.6                      1.5             41.9  
5        30.6             80.2                      0.0             48.2  
6        19.3             92.1                      0.7             42.7  
7        12.2             87.2                      0.0             57.5  
8        39.0             56.1                      1.8             61.8  
9        25.8             62.3                      1.4             81.9  </code></pre>
</div>
</div>
</section>
<section id="数据维度" class="level3">
<h3 class="anchored" data-anchor-id="数据维度">🧮 数据维度</h3>
<ul>
<li><p><strong>样本数（行数）</strong>：<code>637</code> 由 <code>n_patients = 637</code> 指定，模拟的是637位精神分裂症患者的临床与人口学数据。</p></li>
<li><p><strong>变量数（列数）</strong>：<code>17</code> 包括临床症状、人口学特征、功能状态和代谢指标等变量。</p></li>
</ul>
</section>
<section id="变量列表与类型" class="level3">
<h3 class="anchored" data-anchor-id="变量列表与类型">📊 变量列表与类型</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>变量名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Age</code></td>
<td>连续变量</td>
<td>年龄（18–64岁）</td>
</tr>
<tr class="even">
<td><code>Sex_Female</code></td>
<td>二元变量</td>
<td>性别（1=女性，0=男性）</td>
</tr>
<tr class="odd">
<td><code>Education</code></td>
<td>分类变量</td>
<td>教育水平（3类）</td>
</tr>
<tr class="even">
<td><code>Occupation_Employed</code></td>
<td>二元变量</td>
<td>是否就业（1=在职）</td>
</tr>
<tr class="odd">
<td><code>Duration_of_Illness</code></td>
<td>连续变量</td>
<td>病程（0–44年）</td>
</tr>
<tr class="even">
<td><code>Obesity</code></td>
<td>二元变量</td>
<td>是否肥胖</td>
</tr>
<tr class="odd">
<td><code>Hypertension</code></td>
<td>二元变量</td>
<td>是否高血压</td>
</tr>
<tr class="even">
<td><code>Diabetes</code></td>
<td>二元变量</td>
<td>是否糖尿病</td>
</tr>
<tr class="odd">
<td><code>CGI_Positive</code></td>
<td>连续变量</td>
<td>阳性症状评分（1–7）</td>
</tr>
<tr class="even">
<td><code>CGI_Negative</code></td>
<td>连续变量</td>
<td>阴性症状评分（1–7）</td>
</tr>
<tr class="odd">
<td><code>CGI_Depressive</code></td>
<td>连续变量</td>
<td>抑郁症状评分（1–6）</td>
</tr>
<tr class="even">
<td><code>CGI_Cognitive</code></td>
<td>连续变量</td>
<td>认知缺陷评分（1–6）</td>
</tr>
<tr class="odd">
<td><code>SCL90R_Somatization</code></td>
<td>连续变量</td>
<td>躯体化评分（12–58）</td>
</tr>
<tr class="even">
<td><code>SCL90R_OCS</code></td>
<td>连续变量</td>
<td>强迫症状评分（10–50）</td>
</tr>
<tr class="odd">
<td><code>SWN_Total_Score</code></td>
<td>连续变量</td>
<td>主观幸福感评分（24–120）</td>
</tr>
<tr class="even">
<td><code>DIEPSS_Overall_Severity</code></td>
<td>连续变量</td>
<td>锥体外系不良反应评分（0–4）</td>
</tr>
<tr class="odd">
<td><code>PSP_Total_Score</code></td>
<td>连续变量</td>
<td>社会功能评分（10–90）</td>
</tr>
</tbody>
</table>
</section>
<section id="变量探索机器学习进行变量的探索即特征工程" class="level3">
<h3 class="anchored" data-anchor-id="变量探索机器学习进行变量的探索即特征工程">📊 变量探索(机器学习进行变量的探索，即特征工程)</h3>
<hr>
<p><strong>论文的首要分析步骤是利用机器学习 (ML) 来识别决定高水平主观幸福感 (SWB) 的最重要因素。论文作者训练了多个模型，发现随机森林 (RF) 模型表现最佳</strong></p>
<ol type="1">
<li><p>准备机器学习的数据 。</p></li>
<li><p>训练随机森林模型来预测哪些患者具有“高水平的 SWB”。</p></li>
<li><p>使用 AUC 指标评估模型的性能 ，就像论文中所做的那样。</p></li>
<li><p>使用 SHAP 值分析<strong>特征重要性</strong>， 以了解哪些变量是最强大的预测因子，重现论文中图 1B 中的发现。</p></li>
</ol>
<section id="第一步导入需要的包" class="level4">
<h4 class="anchored" data-anchor-id="第一步导入需要的包">第一步导入需要的包🧉</h4>
<ul>
<li>包是可以认为是游戏的mod,都是大佬收集的算法或者其他的代码来实现你需要的功能，这些都是地基</li>
</ul>
<div id="8067cc86" class="cell" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 导入所需的库</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd                 <span class="co"># 导入 pandas 用于读取和处理数据</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np                  <span class="co"># 导入 numpy 用于数值计算</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split <span class="co"># 导入 train_test_split 用于划分训练集和测试集</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> RandomForestClassifier  <span class="co"># 导入随机森林分类器</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> roc_auc_score, roc_curve <span class="co"># 导入评估指标计算函数</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt     <span class="co"># 导入 matplotlib 用于绘图</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shap                         <span class="co"># 导入 SHAP 库用于模型解释</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="第二步导入数据" class="level4">
<h4 class="anchored" data-anchor-id="第二步导入数据">第二步导入数据🤤</h4>
<p>就是我们要的数据，即调查的数据，一般是XLSX(excel表格)，csv(数据格式万金油)，或者其他格式</p>
<div id="c464736a" class="cell" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1. 加载并准备数据 ---</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Load and Prepare the Data</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># !!! 重要提示: 请将下面的路径修改为您保存 CSV 文件的实际位置 !!!</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># For example: "C:/Users/YourUsername/Documents/synthetic_schizophrenia_data.csv"</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> <span class="st">"./synthetic_schizophrenia_data.csv"</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 读取我们之前生成的合成数据</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(file_path)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="第三步-定义目标变量和特征变量" class="level4">
<h4 class="anchored" data-anchor-id="第三步-定义目标变量和特征变量">第三步 定义目标变量和特征变量🥶</h4>
<p>我们必须要知道what the fuck is our 目标变量，即我们要研究的目标，这篇文章研究的是 <strong>高水平主观幸福感 (SWB)</strong>，他们想要知道什么因素影响这个鬼东西，而这些因素，比如年龄，身高，体重就是特征变量</p>
<ul>
<li><strong>定义目标</strong>： 本文机器学习模型的主要目标并非预测准确的主观幸福感 (SWB) 评分，而是将患者分为两组：具有“高水平 SWB”的患者和不具有“高水平 SWB”的患者。我们遵循本文的思路，创建了一个二元目标变量 ( High_SWB )，其中 80 分及以上被视为“高”（编码为 1），低于 80 分则被视为“低”（编码为 0）。</li>
</ul>
<div id="54e02885" class="cell" data-execution_count="4">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 定义目标变量 (Y)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 根据论文，"高水平SWB" 定义为 SWN 总分达到或超过 80</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 我们创建一个名为 'High_SWB' 的新列，1 表示高SWB，0 表示非高SWB</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'High_SWB'</span>] <span class="op">=</span> (df[<span class="st">'SWN_Total_Score'</span>] <span class="op">&gt;=</span> <span class="dv">80</span>).astype(<span class="bu">int</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 定义特征变量 (X)</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># X 是除了目标变量和原始SWN分数之外的所有列</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co"># We drop the original score and the target variable to create our feature set</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> df.drop([<span class="st">'SWN_Total_Score'</span>, <span class="st">'High_SWB'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> df[<span class="st">'High_SWB'</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="特征工程" class="level4">
<h4 class="anchored" data-anchor-id="特征工程">特征工程</h4>
<p>特征工程是指从原始数据中提取有用的特征，以便于机器学习模型的训练和预测。</p>
<p>特征工程包括以下几个方面：</p>
<ol type="1">
<li>特征选择：选择最相关的特征，以减少模型的复杂度，提高模型的泛化能力。即有的时候特征太多，且其中有无意义或者不重要的特征，这时候就需要选择最相关的特征，以减少模型的复杂度，提高模型的泛化能力。</li>
<li>特征提取：从原始数据中提取有用的特征，以便于机器学习模型的训练和预测。</li>
<li>特征变换：对特征进行变换，以便于机器学习模型的训练和预测。比如标准化，归一化，独热编码，等等。 对于一些其他数据类型，比如字符型，如是否为男或者女性，一般可以用1代表男，0代表女，因为模型一般无法了解字的真实含义，但是数字可以。 一般来说，对于特征工程这个步骤需要花费很多时间。我们这个例子的数据比较符合机器学习的类型，不需要太多更改</li>
</ol>
<p>独热编码是将分类变量转换为二进制变量，即将每个分类变量转换为多个二进制变量，每个二进制变量表示一个分类。比如这个例子教育是分为三类，且都为字符型，我们可以把教育分为三个二进制（0/1）变量，每个二进制变量表示一个分类。</p>
<div id="92cf4c47" class="cell" data-execution_count="5">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 处理分类变量</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 'Education' 列是文本类型，机器学习模型需要数值输入。</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 我们使用 "独热编码" (One-Hot Encoding) 将其转换为数值列。</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># This converts the 'Education' column into multiple binary (0/1) columns.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> pd.get_dummies(X, columns<span class="op">=</span>[<span class="st">'Education'</span>], drop_first<span class="op">=</span><span class="va">True</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>接下来我们要进行数据标准化，他的统计学意义我就不说了，但是为什么要进行标准化，标准化可以会将所有特征缩放到均值为0，标准差为1的范围，对于逻辑回归等线性模型很重要，而对于一些随机森林，神经网络等等的黑箱模型不太重要，但是我还是进行标准化。</p>
<div id="8125d561" class="cell" data-execution_count="6">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 数据标准化 (对于逻辑回归等线性模型很重要)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co"># StandardScaler 会将所有特征缩放到均值为0，标准差为1的范围</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">#先导入我们需要的包</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>X_scaled <span class="op">=</span> scaler.fit_transform(X)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>#### 机器学习 我们先定义一堆我们要用的机械学习的模型，论文里面用的是随机森林，逻辑回归，支持向量机，等等</p>
<p>我们将使用五种机器学习模型来预测患者是否具有高水平的主观幸福感（SWB）。每种模型都有不同的特点和适用场景。</p>
<section id="logistic-regression-lr" class="level5">
<h5 class="anchored" data-anchor-id="logistic-regression-lr">1️⃣ Logistic Regression (LR)</h5>
<p>. 逻辑回归是一种经典的线性模型，适用于二分类问题（如：高SWB vs 低SWB）。</p>
<p>. 优点：简单、易解释、计算快。</p>
<p>. 原理：根据每个变量的权重，计算一个概率值（0到1之间），判断属于哪个类别。</p>
<p>. 适用场景：变量之间关系较简单、线性时效果好。</p>
<p>2️⃣ Random Forest (RF) . 随机森林是一种集成学习方法，由多个决策树组成。</p>
<p>. 优点：抗过拟合、能处理非线性关系、对缺失值和异常值鲁棒。</p>
<p>. 原理：每棵树都在不同的数据子集上训练，最终通过“投票”决定预测结果。</p>
<p>. 适用场景：变量多、关系复杂时表现优异。</p>
<p>. 3️⃣ Gradient Boosting Machine (GBM) 梯度提升机是一种逐步优化的集成方法。</p>
<p>. 优点：预测精度高，适合复杂数据结构。</p>
<p>. 原理：每棵新树都专注于纠正前一棵树的错误，逐步提升整体性能。</p>
<p>. 适用场景：需要高精度预测时，GBM是常用选择。</p>
<p>.</p>
<p>4️⃣ XGBoost (XGB) . 极端梯度提升是GBM的高效版本，在数据科学竞赛中非常流行。</p>
<p>. 优点：速度快、性能强、支持缺失值处理和正则化。</p>
<p>. 原理：在GBM基础上加入更多优化策略，如剪枝、并行计算。</p>
<p>. 适用场景：大数据、高维度、需要快速训练时。</p>
<p>5️⃣ LightGBM (LGBM) . 轻量级梯度提升机是另一种高效的GBM变体，专为大规模数据设计。</p>
<p>. 优点：训练速度快、内存占用低、适合高维稀疏数据。</p>
<p>. 原理：使用“叶子优先”策略构建树，提升效率。</p>
<p>. 适用场景：数据量大、变量多时非常适合。</p>
<p><strong>当然，随着现在算法的升级，还有很多算法在他们之上有更好的表现，也要根据数据和模型的用途进行匹配</strong></p>
<p>📊 为什么要比较多个模型？ 不同模型对数据的敏感性不同，适合的场景也不同。</p>
<p>比较多个模型可以找到最稳定、最准确的预测方法。</p>
<div id="11f8466c" class="cell" data-execution_count="7">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">#  定义要比较的模型 ---</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 依旧导入需要的包</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> RandomForestClassifier, GradientBoostingClassifier</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> xgboost <span class="im">as</span> xgb</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> lightgbm <span class="im">as</span> lgb</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 我们将所有模型储存在一个字典中，方便循环调用</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>models <span class="op">=</span> {</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Logistic Regression (LR)"</span>: LogisticRegression(max_iter<span class="op">=</span><span class="dv">1000</span>, random_state<span class="op">=</span><span class="dv">42</span>),</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Random Forest (RF)"</span>: RandomForestClassifier(n_estimators<span class="op">=</span><span class="dv">500</span>, max_depth<span class="op">=</span><span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>),</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Gradient Boosting (GBM)"</span>: GradientBoostingClassifier(n_estimators<span class="op">=</span><span class="dv">200</span>, max_depth<span class="op">=</span><span class="dv">3</span>, random_state<span class="op">=</span><span class="dv">42</span>),</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"XGBoost (XGB)"</span>: xgb.XGBClassifier(n_estimators<span class="op">=</span><span class="dv">200</span>, max_depth<span class="op">=</span><span class="dv">3</span>, use_label_encoder<span class="op">=</span><span class="va">False</span>, eval_metric<span class="op">=</span><span class="st">'logloss'</span>, random_state<span class="op">=</span><span class="dv">42</span>),</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"LightGBM (LGBM)"</span>: lgb.LGBMClassifier(n_estimators<span class="op">=</span><span class="dv">200</span>, max_depth<span class="op">=</span><span class="dv">3</span>, random_state<span class="op">=</span><span class="dv">42</span>, verbosity<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="使用-5-折交叉验证评估所有模型" class="level5">
<h5 class="anchored" data-anchor-id="使用-5-折交叉验证评估所有模型">🧪 使用 5 折交叉验证评估所有模型</h5>
<p>在这一部分，我们将对五种机器学习模型进行性能评估，使用的是一种非常稳健的方法：5 折交叉验证（5-fold cross-validation）。</p>
<p>. ✅ 什么是交叉验证？ 交叉验证是一种将数据集分成多个“子集”来训练和测试模型的方法。</p>
<p>. 在 5 折交叉验证中，我们将数据分成 5 份：</p>
<p>. 每次用其中 4 份训练模型，剩下 1 份测试模型。</p>
<p>. 这个过程重复 5 次，每次测试集都不同。</p>
<p>. 最后我们计算 5 次的平均性能指标（如 AUC），得到一个更稳定的评估结果。</p>
<p>. 这种方法比单次训练/测试划分更可靠，能减少“运气好/坏”带来的误差。</p>
<p>. 📊 为什么选择 AUC？ . AUC 是衡量模型区分能力的指标，值越接近 1，模型越好。</p>
<div id="116d2e10" class="cell" data-execution_count="8">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> cross_val_score</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {} <span class="co"># 创建一个空字典来储存结果</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"正在使用5折交叉验证评估每个模型..."</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 循环遍历我们定义的每个模型</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> model_name, model <span class="kw">in</span> models.items():</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 对线性模型（逻辑回归）使用标准化后的数据</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> model_name <span class="op">==</span> <span class="st">"Logistic Regression (LR)"</span>:</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        X_input <span class="op">=</span> X_scaled</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="co"># 对树模型使用原始编码后的数据</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        X_input <span class="op">=</span> X</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 使用 cross_val_score 函数进行5折交叉验证</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># cv=5: 指定了折数</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># scoring='roc_auc': 指定评估指标为 AUC</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    cv_scores <span class="op">=</span> cross_val_score(model, X_input, y, cv<span class="op">=</span><span class="dv">5</span>, scoring<span class="op">=</span><span class="st">'roc_auc'</span>)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 将每个模型的名称和其5次交叉验证的平均分及标准差存入结果字典</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    results[model_name] <span class="op">=</span> {</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        <span class="st">'mean_auc'</span>: np.mean(cv_scores),</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        <span class="st">'std_auc'</span>: np.std(cv_scores)</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 打印每个模型的评估结果</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>model_name<span class="sc">}</span><span class="ss">: 平均 AUC = </span><span class="sc">{</span>results[model_name][<span class="st">'mean_auc'</span>]<span class="sc">:.4f}</span><span class="ss"> (标准差 = </span><span class="sc">{</span>results[model_name][<span class="st">'std_auc'</span>]<span class="sc">:.4f}</span><span class="ss">)"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>正在使用5折交叉验证评估每个模型...
  Logistic Regression (LR): 平均 AUC = 0.7916 (标准差 = 0.0327)
  Random Forest (RF): 平均 AUC = 0.7977 (标准差 = 0.0466)
  Gradient Boosting (GBM): 平均 AUC = 0.7571 (标准差 = 0.0341)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>d:\pythontext\.venv\Lib\site-packages\xgboost\core.py:158: UserWarning:

[12:04:37] WARNING: C:\buildkite-agent\builds\buildkite-windows-cpu-autoscaling-group-i-08cbc0333d8d4aae1-1\xgboost\xgboost-ci-windows\src\learner.cc:740: 
Parameters: { "use_label_encoder" } are not used.


d:\pythontext\.venv\Lib\site-packages\xgboost\core.py:158: UserWarning:

[12:04:37] WARNING: C:\buildkite-agent\builds\buildkite-windows-cpu-autoscaling-group-i-08cbc0333d8d4aae1-1\xgboost\xgboost-ci-windows\src\learner.cc:740: 
Parameters: { "use_label_encoder" } are not used.


d:\pythontext\.venv\Lib\site-packages\xgboost\core.py:158: UserWarning:

[12:04:37] WARNING: C:\buildkite-agent\builds\buildkite-windows-cpu-autoscaling-group-i-08cbc0333d8d4aae1-1\xgboost\xgboost-ci-windows\src\learner.cc:740: 
Parameters: { "use_label_encoder" } are not used.


d:\pythontext\.venv\Lib\site-packages\xgboost\core.py:158: UserWarning:

[12:04:37] WARNING: C:\buildkite-agent\builds\buildkite-windows-cpu-autoscaling-group-i-08cbc0333d8d4aae1-1\xgboost\xgboost-ci-windows\src\learner.cc:740: 
Parameters: { "use_label_encoder" } are not used.


d:\pythontext\.venv\Lib\site-packages\xgboost\core.py:158: UserWarning:

[12:04:37] WARNING: C:\buildkite-agent\builds\buildkite-windows-cpu-autoscaling-group-i-08cbc0333d8d4aae1-1\xgboost\xgboost-ci-windows\src\learner.cc:740: 
Parameters: { "use_label_encoder" } are not used.

</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>  XGBoost (XGB): 平均 AUC = 0.7572 (标准差 = 0.0422)
  LightGBM (LGBM): 平均 AUC = 0.7609 (标准差 = 0.0444)</code></pre>
</div>
</div>
<p>这些 LightGBM 的日志信息和警告是模型训练过程中的正常输出，尤其是这句：</p>
<blockquote class="blockquote">
<p><strong>[Warning] No further splits with positive gain, best gain: -inf</strong></p>
</blockquote>
<p>它的意思是：在某一轮训练中，LightGBM 没有找到任何可以继续分裂的节点（即没有“正增益”的分裂点），所以该轮的树构建就提前终止了。这通常是因为：</p>
<ul>
<li><p>数据已经被很好地拟合；</p></li>
<li><p>当前参数限制了树的复杂度（如 <code>max_depth</code>、<code>min_data_in_leaf</code> 等）；</p></li>
<li><p>或者数据本身不支持进一步分裂（例如样本太少或特征太弱）。</p></li>
</ul>
<p>这不是错误，也不会影响模型的正常训练和预测性能。</p>
</section>
</section>
<section id="可视化结果" class="level4">
<h4 class="anchored" data-anchor-id="可视化结果">可视化结果🤨</h4>
<p>. 比较平均 AUC 分数： 查看打印的输出和条形图。您将看到五个模型的平均 AUC 分数。 与原始论文一致，您可能会发现所有高级模型（RF，GBM，XGB，LGBM）的表现非常相似，并且明显优于基线 Logistic 回归模型 。</p>
<p>随机森林模型可能仍然略占优势，就像论文中提到的那样，AUC 得分在 0.79-0.80 左右 。这证实了我们之前的发现，但现在的置信度更高了。顶级模型之间性能接近，这是机器学习中一个非常常见且重要的发现。</p>
<p>标准差（误差线）的重要性： 标准差（由条形图上的黑色“误差线”表示）告诉您模型的性能在 5 个不同折叠之间的差异有多大。 标准差越小（误差线越短），效果越好。 这意味着模型稳定，其性能不会严重依赖于训练时所用的特定数据子集。</p>
<p>您可能会注意到基于树的模型具有相对较低的方差，这表明它们很稳定。</p>
<div id="2c5c59e9" class="cell" data-execution_count="9">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 将结果字典转换为 DataFrame，方便绘图</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>results_df <span class="op">=</span> pd.DataFrame(results).T.sort_values(by<span class="op">=</span><span class="st">'mean_auc'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">7</span>))</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>bars <span class="op">=</span> plt.bar(results_df.index, results_df[<span class="st">'mean_auc'</span>], yerr<span class="op">=</span>results_df[<span class="st">'std_auc'</span>], capsize<span class="op">=</span><span class="dv">5</span>, color<span class="op">=</span><span class="st">'skyblue'</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 在每个柱状图上显示数值</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> bar <span class="kw">in</span> bars:</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    yval <span class="op">=</span> bar.get_height()</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    plt.text(bar.get_x() <span class="op">+</span> bar.get_width()<span class="op">/</span><span class="fl">2.0</span>, yval <span class="op">+</span> <span class="fl">0.01</span>, <span class="ss">f'</span><span class="sc">{</span>yval<span class="sc">:.3f}</span><span class="ss">'</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'bottom'</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Mean AUC Score '</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Machine Learning Models '</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Comparison of ML Models using 5-Fold Cross-Validation '</span>)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>, <span class="fl">1.0</span>) <span class="co"># 设置y轴范围为0到1</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">15</span>) <span class="co"># 旋转x轴标签，防止重叠</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>plt.grid(axis<span class="op">=</span><span class="st">'y'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-10-output-1.png" width="961" height="640" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>🎯 模型表现排名（按 AUC）</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>模型名称</th>
<th>平均 AUC 分数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>🥇 <strong>Random Forest (RF)</strong></td>
<td><strong>0.798</strong></td>
</tr>
<tr class="even">
<td>🥈 Logistic Regression (LR)</td>
<td>0.792</td>
</tr>
<tr class="odd">
<td>🥉 LightGBM (LGBM)</td>
<td>0.760</td>
</tr>
<tr class="even">
<td>XGBoost (XGB)</td>
<td>0.758</td>
</tr>
<tr class="odd">
<td>Gradient Boosting (GBM)</td>
<td>0.757</td>
</tr>
</tbody>
</table>
<p><strong>📌 评估</strong></p>
<blockquote class="blockquote">
<p>在这次评估中，<strong>Random Forest</strong> 不仅在平均 AUC 上领先，而且其稳定性也很高（标准差较小）。这说明它在不同数据划分下都能保持良好的预测能力，是一个非常可靠的模型选择。</p>
</blockquote>
<ul>
<li><p>虽然逻辑回归易于解释，但在复杂数据中，集成树模型（如 RF）往往能捕捉更丰富的非线性关系；</p></li>
<li><p>RF 的优势在于“稳健性”和“泛化能力”，尤其适合临床数据这种变量多、结构复杂的场景；</p></li>
<li><p>这也验证了原始论文的结论：RF 是预测主观幸福感的首选模型之一。</p></li>
</ul>
<hr>
</section>
</section>
<section id="改进模型" class="level2">
<h2 class="anchored" data-anchor-id="改进模型">改进模型🤖🤖</h2>
<p>虽然我们的模型AUC有0.8左右，这样的数据已经不错了，如果比较原来的论文<a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC12236327/#s5">原论文链接</a></p>
<p><code>The random forest (RF) model had the highest area under the curve (AUC) of 0.794 at baseline. Obsessive-compulsive symptoms (OCS) had the most significant impact on high levels of SWB, followed by somatization, cognitive deficits, and depression. The network analysis demonstrated robust connections among the SWB, OCS, and somatization. SEM analysis revealed that OCS exerted the strongest direct effect on SWB, and also an indirect effect via the mediation of depression. Furthermore, the contribution of OCS at baseline to SWB was maintained 6 months later.随机森林 (RF) 模型的基线曲线下面积 (AUC) 最高，为 0.794。强迫症状 (OCS) 对高水平主观幸福感 (SWB) 的影响最为显著，其次是躯体化、认知缺陷和抑郁症。网络分析表明，SWB、OCS 和躯体化之间存在稳态联系。结构方程模型 (SEM) 分析显示，OCS 对 SWB 的直接影响最为显著，并且也通过抑郁症的中介产生间接影响。此外，基线 OCS 对 SWB 的贡献在 6 个月后得以维持。</code></p>
<p>看起来确实已经不错了，但是我们还是可以对原来的模型进行改善，这是原论文没有进行的操作，具体有两种方法，在模型不改变的情况下</p>
<p><strong>特征选择（Feature Selection）</strong> 和 <strong>超参数调整（Hyperparameter Tuning）</strong></p>
<section id="为什么要进行特征选择" class="level4">
<h4 class="anchored" data-anchor-id="为什么要进行特征选择">🧠 为什么要进行特征选择？</h4>
<blockquote class="blockquote">
<p><strong>理念：少即是多（Less is More）</strong></p>
</blockquote>
<p>在机器学习中，使用所有变量并不总是最好的选择。有些变量可能：</p>
<ul>
<li><p>与目标无关（噪声）；</p></li>
<li><p>与其他变量高度冗余（重复信息）；</p></li>
<li><p>增加模型复杂度，导致过拟合；</p></li>
<li><p>降低模型解释性，让临床人员难以理解。</p></li>
</ul>
</section>
<section id="特征选择的好处" class="level3">
<h3 class="anchored" data-anchor-id="特征选择的好处">✅ 特征选择的好处：</h3>
<ul>
<li><p><strong>提升模型性能</strong>：去除无关变量后，模型更专注于有效信息；</p></li>
<li><p><strong>提高训练速度</strong>：变量少，计算更快；</p></li>
<li><p><strong>增强解释性</strong>：更容易向临床人员解释模型决策；</p></li>
<li><p><strong>减少过拟合风险</strong>：模型更稳健，泛化能力更强。</p></li>
</ul>
<section id="为什么要进行超参数调整" class="level4">
<h4 class="anchored" data-anchor-id="为什么要进行超参数调整">🔧 为什么要进行超参数调整？</h4>
<blockquote class="blockquote">
<p><strong>理念：模型的“个性化设置”决定它的表现</strong></p>
</blockquote>
<p>每个机器学习模型都有一些“内部设置”，称为<strong>超参数</strong>（hyperparameters），它们不是从数据中学出来的，而是你提前设定的。</p>
<p>例如：</p>
<ul>
<li><p>随机森林的 <code>n_estimators</code>（树的数量）、<code>max_depth</code>（树的最大深度）；</p></li>
<li><p>XGBoost 的 <code>learning_rate</code>（学习率）、<code>subsample</code>（样本采样比例）；</p></li>
<li><p>LightGBM 的 <code>num_leaves</code>（叶子数）、<code>min_data_in_leaf</code>（每个叶子最少样本数）。</p></li>
</ul>
</section>
</section>
<section id="超参数调整的好处" class="level3">
<h3 class="anchored" data-anchor-id="超参数调整的好处">✅ 超参数调整的好处：</h3>
<ul>
<li><p><strong>提升模型性能</strong>：找到最适合当前数据的参数组合；</p></li>
<li><p><strong>控制模型复杂度</strong>：防止过拟合或欠拟合；</p></li>
<li><p><strong>增强模型稳定性</strong>：提高在不同数据划分下的表现一致性。</p></li>
</ul>
</section>
<section id="特征选择" class="level3">
<h3 class="anchored" data-anchor-id="特征选择">特征选择🤩</h3>
<div id="47fdf8bb" class="cell" data-execution_count="10">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 导入所需的库</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> cross_val_score</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> RandomForestClassifier</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 2. 识别最重要的特征 ---</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Identify the most important features</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co">#和以前一样导入数据</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1. 加载并准备数据 (与之前相同) ---</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Load and Prepare the Data</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co"># !!! 重要提示: 请将下面的路径修改为您保存 CSV 文件的实际位置 !!!</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> <span class="st">"./synthetic_schizophrenia_data.csv"</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(file_path)</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'High_SWB'</span>] <span class="op">=</span> (df[<span class="st">'SWN_Total_Score'</span>] <span class="op">&gt;=</span> <span class="dv">80</span>).astype(<span class="bu">int</span>)</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> df.drop([<span class="st">'SWN_Total_Score'</span>, <span class="st">'High_SWB'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> df[<span class="st">'High_SWB'</span>]</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> pd.get_dummies(X, columns<span class="op">=</span>[<span class="st">'Education'</span>], drop_first<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"--- 方法一: 特征选择 ---"</span>)</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"首先，我们训练一个基础模型来获取特征重要性..."</span>)</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a><span class="co"># 训练一个临时的随机森林模型来获取特征重要性排序</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>temp_rf <span class="op">=</span> RandomForestClassifier(n_estimators<span class="op">=</span><span class="dv">500</span>, max_depth<span class="op">=</span><span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>temp_rf.fit(X, y)</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建一个包含特征名称和其重要性分数的 DataFrame</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>feature_importances <span class="op">=</span> pd.DataFrame({</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    <span class="st">'feature'</span>: X.columns,</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>    <span class="st">'importance'</span>: temp_rf.feature_importances_</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>}).sort_values(<span class="st">'importance'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a><span class="co"># 打印最重要的特征</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">根据基础模型得出的特征重要性排序:"</span>)</span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(feature_importances)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>--- 方法一: 特征选择 ---
首先，我们训练一个基础模型来获取特征重要性...

根据基础模型得出的特征重要性排序:
                         feature  importance
12                    SCL90R_OCS    0.303654
9                 CGI_Depressive    0.153773
11           SCL90R_Somatization    0.127664
14               PSP_Total_Score    0.098338
8                   CGI_Negative    0.057625
3            Duration_of_Illness    0.050011
7                   CGI_Positive    0.049062
10                 CGI_Cognitive    0.048823
0                            Age    0.040797
13       DIEPSS_Overall_Severity    0.026666
4                        Obesity    0.009579
6                       Diabetes    0.007630
2            Occupation_Employed    0.006329
15         Education_High school    0.006138
5                   Hypertension    0.004924
1                     Sex_Female    0.004714
16  Education_Less than 12 years    0.004275</code></pre>
</div>
</div>
<section id="删除建议按重要性断层" class="level4">
<h4 class="anchored" data-anchor-id="删除建议按重要性断层">📊 删除建议（按重要性断层）</h4>
<p>我打算删除的变量，其重要性如下：</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>特征名称</th>
<th>重要性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DIEPSS_Overall_Severity</td>
<td>0.0267</td>
</tr>
<tr class="even">
<td>Obesity</td>
<td>0.0096</td>
</tr>
<tr class="odd">
<td>Diabetes</td>
<td>0.0076</td>
</tr>
<tr class="even">
<td>Occupation_Employed</td>
<td>0.0063</td>
</tr>
<tr class="odd">
<td>Education_High school</td>
<td>0.0061</td>
</tr>
<tr class="even">
<td>Hypertension</td>
<td>0.0049</td>
</tr>
<tr class="odd">
<td>Sex_Female</td>
<td>0.0047</td>
</tr>
<tr class="even">
<td>Education_Less than 12 years</td>
<td>0.0043</td>
</tr>
</tbody>
</table>
<p>这些变量都和 <code>Age</code> 的重要性（0.0408）断层，说明它们可能对模型预测贡献非常有限。</p>
<p>但是考虑到<code>DIEPSS_Oerall_Severity</code>对于实际意义的确有影响，且和其后面的也断层了，所以我打算保留</p>
<p><strong><em>特征选择不仅是“数学问题”，也是“领域知识问题”。</em></strong></p>
<p>所以我们已经选出了<strong><em>10个贡献比较大的特征</em></strong></p>
<div id="750d8994" class="cell" data-execution_count="11">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 选择最重要的前 10 个特征</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>N_TOP_FEATURES <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>top_features <span class="op">=</span> feature_importances[<span class="st">'feature'</span>].head(N_TOP_FEATURES).tolist()</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">我们将选择最重要的 </span><span class="sc">{</span>N_TOP_FEATURES<span class="sc">}</span><span class="ss"> 个特征进行建模: </span><span class="sc">{</span>top_features<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建只包含最重要特征的新数据集</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>X_selected <span class="op">=</span> X[top_features]</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 在筛选后的特征上重新评估模型 ---</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Re-evaluate the model on selected features</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">使用筛选出的特征进行5折交叉验证..."</span>)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 使用与之前相同的模型配置</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>model_on_selected_features <span class="op">=</span> RandomForestClassifier(n_estimators<span class="op">=</span><span class="dv">500</span>, max_depth<span class="op">=</span><span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>cv_scores_selected <span class="op">=</span> cross_val_score(model_on_selected_features, X_selected, y, cv<span class="op">=</span><span class="dv">5</span>, scoring<span class="op">=</span><span class="st">'roc_auc'</span>)</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="co"># 打印结果</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>mean_auc_selected <span class="op">=</span> np.mean(cv_scores_selected)</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">使用最重要的 </span><span class="sc">{</span>N_TOP_FEATURES<span class="sc">}</span><span class="ss"> 个特征, 模型的平均 AUC 分数是: </span><span class="sc">{</span>mean_auc_selected<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"原始模型的平均 AUC 分数是: 0.7980 (作为对比)"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
我们将选择最重要的 10 个特征进行建模: ['SCL90R_OCS', 'CGI_Depressive', 'SCL90R_Somatization', 'PSP_Total_Score', 'CGI_Negative', 'Duration_of_Illness', 'CGI_Positive', 'CGI_Cognitive', 'Age', 'DIEPSS_Overall_Severity']

使用筛选出的特征进行5折交叉验证...

使用最重要的 10 个特征, 模型的平均 AUC 分数是: 0.7991
原始模型的平均 AUC 分数是: 0.7980 (作为对比)</code></pre>
</div>
</div>
<p>为了加以区别，我们分别复制代码，选取9个和11个特征进行训练看看有什么区别，即剔除<code>DIEPSS_Overall_Severity 0.026666</code> 和加上不太重要的<code>Obesity 0.009579</code>的变量</p>
<div id="3af3dcea" class="cell" data-execution_count="12">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 选择最重要的前 9 个特征</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">#剔除DIEPSS_Overall_Severity 0.026666</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>N_TOP_FEATURES <span class="op">=</span> <span class="dv">9</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>top_features <span class="op">=</span> feature_importances[<span class="st">'feature'</span>].head(N_TOP_FEATURES).tolist()</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">我们将选择最重要的 </span><span class="sc">{</span>N_TOP_FEATURES<span class="sc">}</span><span class="ss"> 个特征进行建模: </span><span class="sc">{</span>top_features<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建只包含最重要特征的新数据集</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>X_selected <span class="op">=</span> X[top_features]</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 在筛选后的特征上重新评估模型 ---</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Re-evaluate the model on selected features</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">使用筛选出的特征进行5折交叉验证..."</span>)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 使用与之前相同的模型配置</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>model_on_selected_features <span class="op">=</span> RandomForestClassifier(n_estimators<span class="op">=</span><span class="dv">500</span>, max_depth<span class="op">=</span><span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>cv_scores_selected <span class="op">=</span> cross_val_score(model_on_selected_features, X_selected, y, cv<span class="op">=</span><span class="dv">5</span>, scoring<span class="op">=</span><span class="st">'roc_auc'</span> )</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="co"># 打印结果</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>mean_auc_selected <span class="op">=</span> np.mean(cv_scores_selected)</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">使用最重要的 </span><span class="sc">{</span>N_TOP_FEATURES<span class="sc">}</span><span class="ss"> 个特征, 模型的平均 AUC 分数是: </span><span class="sc">{</span>mean_auc_selected<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"原始模型的平均 AUC 分数是: 0.7980 (作为对比)"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
我们将选择最重要的 9 个特征进行建模: ['SCL90R_OCS', 'CGI_Depressive', 'SCL90R_Somatization', 'PSP_Total_Score', 'CGI_Negative', 'Duration_of_Illness', 'CGI_Positive', 'CGI_Cognitive', 'Age']

使用筛选出的特征进行5折交叉验证...

使用最重要的 9 个特征, 模型的平均 AUC 分数是: 0.7975
原始模型的平均 AUC 分数是: 0.7980 (作为对比)</code></pre>
</div>
</div>
<div id="ec1bed1e" class="cell" data-execution_count="13">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 选择最重要的前 11 个特征</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 加上不太重要的Obesity 0.009579的变量</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>N_TOP_FEATURES <span class="op">=</span> <span class="dv">11</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>top_features <span class="op">=</span> feature_importances[<span class="st">'feature'</span>].head(N_TOP_FEATURES).tolist()</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">我们将选择最重要的 </span><span class="sc">{</span>N_TOP_FEATURES<span class="sc">}</span><span class="ss"> 个特征进行建模: </span><span class="sc">{</span>top_features<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建只包含最重要特征的新数据集</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>X_selected <span class="op">=</span> X[top_features]</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 在筛选后的特征上重新评估模型 ---</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Re-evaluate the model on selected features</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">使用筛选出的特征进行5折交叉验证..."</span>)</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 使用与之前相同的模型配置</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>model_on_selected_features <span class="op">=</span> RandomForestClassifier(n_estimators<span class="op">=</span><span class="dv">500</span>, max_depth<span class="op">=</span><span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>cv_scores_selected <span class="op">=</span> cross_val_score(model_on_selected_features, X_selected, y, cv<span class="op">=</span><span class="dv">5</span>, scoring<span class="op">=</span><span class="st">'roc_auc'</span>)</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="co"># 打印结果</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>mean_auc_selected <span class="op">=</span> np.mean(cv_scores_selected)</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">使用最重要的 </span><span class="sc">{</span>N_TOP_FEATURES<span class="sc">}</span><span class="ss"> 个特征, 模型的平均 AUC 分数是: </span><span class="sc">{</span>mean_auc_selected<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"原始模型的平均 AUC 分数是: 0.7980 (作为对比)"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
我们将选择最重要的 11 个特征进行建模: ['SCL90R_OCS', 'CGI_Depressive', 'SCL90R_Somatization', 'PSP_Total_Score', 'CGI_Negative', 'Duration_of_Illness', 'CGI_Positive', 'CGI_Cognitive', 'Age', 'DIEPSS_Overall_Severity', 'Obesity']

使用筛选出的特征进行5折交叉验证...

使用最重要的 11 个特征, 模型的平均 AUC 分数是: 0.7974
原始模型的平均 AUC 分数是: 0.7980 (作为对比)</code></pre>
</div>
</div>
</section>
<section id="教学总结特征选择的实证价值" class="level4">
<h4 class="anchored" data-anchor-id="教学总结特征选择的实证价值">🎯 教学总结：特征选择的实证价值</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>特征数量</th>
<th>平均 AUC 分数</th>
<th>相对表现</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>原始模型（全部特征）</td>
<td>0.7980</td>
<td>基准</td>
</tr>
<tr class="even">
<td>最重要的 10 个特征</td>
<td><strong>0.7991</strong></td>
<td>✅ 最佳表现</td>
</tr>
<tr class="odd">
<td>最重要的 9 个特征（剔除 DIEPSS）</td>
<td>0.7975</td>
<td>略低</td>
</tr>
<tr class="even">
<td>最重要的 11 个特征（加入 Obesity）</td>
<td>0.7974</td>
<td>略低</td>
</tr>
</tbody>
</table>
</section>
<section id="要点一不是特征越多越好" class="level4">
<h4 class="anchored" data-anchor-id="要点一不是特征越多越好">🧠 要点一：不是特征越多越好</h4>
<blockquote class="blockquote">
<p>增加变量并不一定提升模型性能，反而可能引入噪声或冗余信息。</p>
</blockquote>
<ul>
<li><p>加入 <strong>Obesity（0.009579）</strong> 后，模型性能略微下降；</p></li>
<li><p>删除 <strong>DIEPSS（0.026666）</strong> 后，模型也略微下降；</p></li>
<li><p>说明这两个变量虽然贡献不大，但也不是完全无效，尤其 DIEPSS 可能有一定临床解释价值。</p></li>
</ul>
</section>
<section id="要点二找到最佳变量组合才是关键" class="level4">
<h4 class="anchored" data-anchor-id="要点二找到最佳变量组合才是关键">🧠 要点二：找到“最佳变量组合”才是关键</h4>
<blockquote class="blockquote">
<p>10个变量组合的模型表现最好，说明它在信息量与简洁性之间达到了平衡。</p>
</blockquote>
<ul>
<li><p>这个组合既保留了高贡献变量，又避免了低贡献变量的干扰；</p></li>
<li><p>模型更快、更稳定、更易解释；。</p></li>
</ul>
</section>
<section id="要点三进行变量敏感性分析" class="level4">
<h4 class="anchored" data-anchor-id="要点三进行变量敏感性分析">🧠 要点三：进行“变量敏感性分析”</h4>
<ul>
<li><p>逐个添加或剔除变量，观察模型性能变化；</p></li>
<li><p>结合领域知识判断是否保留某些临床重要但模型贡献较低的变量；</p></li>
<li><p>用图表展示 AUC 随变量数量变化的趋势，强化“变量选择是策略性决策”的理念。</p></li>
</ul>
</section>
</section>
<section id="超参数调优" class="level3">
<h3 class="anchored" data-anchor-id="超参数调优">超参数调优🎃</h3>
<p>例如，假设 n_estimators=500，max_depth=5，但这些设置可能并非我们特定“赛道”（数据集）的最佳设置。通过系统地尝试这些设置的不同组合，我们可以找到能够实现最佳性能的配置 #### 先是网格搜索</p>
<p>手动定义一个固定的 param_grid 然后进行“暴力”搜索（Brute-force Search），是超参数调优最基础的方法</p>
<div id="52f23765" class="cell" data-execution_count="14">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 导入 GridSearchCV</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> GridSearchCV</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n\n</span><span class="st">--- 方法二: 超参数调优 (这可能需要几分钟) ---"</span>)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1. 定义要搜索的超参数网格 ---</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the parameter grid to search</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 这是一个我们要测试的超参数组合的 "菜单"</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>param_grid <span class="op">=</span> {</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">'n_estimators'</span>: [<span class="dv">200</span>, <span class="dv">400</span>, <span class="dv">600</span>],       <span class="co"># 树的数量</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">'max_depth'</span>: [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>],             <span class="co"># 树的最大深度</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">'min_samples_leaf'</span>: [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>],         <span class="co"># 一个叶节点上最少的样本数</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">'max_features'</span>: [<span class="st">'sqrt'</span>, <span class="st">'log2'</span>]       <span class="co"># 每次分裂时考虑的最大特征数</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 2. 设置并运行 GridSearchCV ---</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Setup and run GridSearchCV</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a><span class="co"># 初始化我们的基础模型</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>rf_base <span class="op">=</span> RandomForestClassifier(random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a><span class="co"># 设置 GridSearchCV</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a><span class="co"># estimator: 我们要调优的模型</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a><span class="co"># param_grid: 我们定义的参数网格</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span class="co"># cv=5: 使用5折交叉验证来评估每一种参数组合</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a><span class="co"># scoring='roc_auc': 我们的评估指标</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>grid_search <span class="op">=</span> GridSearchCV(estimator<span class="op">=</span>rf_base, param_grid<span class="op">=</span>param_grid, cv<span class="op">=</span><span class="dv">5</span>, scoring<span class="op">=</span><span class="st">'roc_auc'</span> , verbose<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a><span class="co"># 在完整数据集上运行网格搜索</span></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>grid_search.fit(X, y)</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 打印最佳结果 ---</span></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the best results</span></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">超参数调优完成!"</span>)</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a><span class="co"># 打印找到的最佳参数组合</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"找到的最佳超参数组合 (Best Parameters): </span><span class="ch">\n</span><span class="sc">{</span>grid_search<span class="sc">.</span>best_params_<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a><span class="co"># 打印使用最佳参数时，交叉验证得到的最佳AUC分数</span></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">使用最佳参数时，模型的最佳平均 AUC 分数是: </span><span class="sc">{</span>grid_search<span class="sc">.</span>best_score_<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>

--- 方法二: 超参数调优 (这可能需要几分钟) ---
Fitting 5 folds for each of 72 candidates, totalling 360 fits

超参数调优完成!
找到的最佳超参数组合 (Best Parameters): 
{'max_depth': 5, 'max_features': 'sqrt', 'min_samples_leaf': 3, 'n_estimators': 200}

使用最佳参数时，模型的最佳平均 AUC 分数是: 0.7997</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>d:\pythontext\.venv\Lib\site-packages\numpy\ma\core.py:2846: RuntimeWarning:

invalid value encountered in cast
</code></pre>
</div>
</div>
<p>使用最佳参数时，模型的最佳平均 AUC 分数是: 0.7997 正如我说，网格搜索是超参数最基础的方法，但它有两个主要缺点：</p>
<ol type="1">
<li><p><strong>维度诅咒 (Curse of Dimensionality):</strong> 当参数和你想尝试的值变多时，组合的数量会呈指数级增长，导致计算成本极高，非常耗时。</p></li>
<li><p><strong>效率低下:</strong> 它会花费大量时间去尝试那些明显不佳的参数组合。</p></li>
</ol>
<p>接下来我会用一个更加爽的方法，<strong><em>即贝叶斯优化</em></strong></p>
<p>这是目前最先进和最高效的调优方法之一，它完美地体现了“迭代选择最好”的思想。</p>
<p><strong>核心思想：</strong><br>
贝叶斯优化会建立一个关于“哪个参数组合可能得到更高分数”的概率模型。</p>
<ol type="1">
<li><p>它首先尝试几个随机的参数组合。</p></li>
<li><p>然后，它根据已有的结果，更新内部的概率模型，预测出“最有希望”提升分数的下一个参数组合。</p></li>
<li><p>它会去尝试这个“最有希望”的组合，然后再次更新模型。</p></li>
<li><p>这个过程会不断迭代，智能地将搜索资源集中在参数空间中最有潜力的区域。</p></li>
</ol>
<p><strong>打个比方：</strong> 这就像在一个大雾弥漫的山区里找最高峰。你不会在地毯式搜索每一寸土地（网格搜索），而是根据你当前所在位置的高度和坡度，来判断下一步往哪个方向走最有可能登得更高。</p>
<p><strong>🥸不过需要注意的是，由于是随机组合，每次远行代码得到的最好的结果都不一样，就好像在乌泱泱的大海找最大的船，有的时候你不一定能找到山东舰航母，可能只会找到护卫舰</strong></p>
<div id="a66050be" class="cell" data-execution_count="15">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 导入 optuna 库</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optuna</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> cross_val_score</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n\n</span><span class="st">--- 最智能的调优方法二: 贝叶斯优化 (Bayesian Optimization with Optuna) ---"</span>)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Optuna 会根据历史结果，智能地选择下一次要尝试的超参数..."</span>)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1. 定义一个 "目标函数" (Objective Function) ---</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 这个函数告诉 Optuna 如何评估一组超参数的好坏</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> objective(trial):</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 'trial' 对象用于建议超参数的值</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Optuna 会智能地决定建议值的范围和具体值</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    params <span class="op">=</span> {</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">'n_estimators'</span>: trial.suggest_int(<span class="st">'n_estimators'</span>, <span class="dv">200</span>, <span class="dv">800</span>), <span class="co"># 建议一个在 [200, 800] 范围内的整数</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">'max_depth'</span>: trial.suggest_int(<span class="st">'max_depth'</span>, <span class="dv">3</span>, <span class="dv">10</span>),</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">'min_samples_leaf'</span>: trial.suggest_int(<span class="st">'min_samples_leaf'</span>, <span class="dv">1</span>, <span class="dv">10</span>),</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">'max_features'</span>: trial.suggest_categorical(<span class="st">'max_features'</span>, [<span class="st">'sqrt'</span>, <span class="st">'log2'</span>]),</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 使用这组参数创建并评估模型</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> RandomForestClassifier(random_state<span class="op">=</span><span class="dv">42</span>, <span class="op">**</span>params)</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 使用交叉验证来获得稳健的分数</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    score <span class="op">=</span> cross_val_score(model, X, y, cv<span class="op">=</span><span class="dv">5</span>, scoring<span class="op">=</span><span class="st">'roc_auc'</span>, ).mean()</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Optuna 的目标是最大化这个返回值</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> score</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 2. 创建一个 "研究" (Study) 并开始优化 ---</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a><span class="co"># direction='maximize': 告诉 Optuna 我们的目标是最大化 objective 函数的返回值</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>study <span class="op">=</span> optuna.create_study(direction<span class="op">=</span><span class="st">'maximize'</span>, study_name<span class="op">=</span><span class="st">'RF_Optimization'</span>)</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a><span class="co"># n_trials=100: 运行100次迭代。Optuna 会在这100次中智能地寻找最优解。</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>study.optimize(objective, n_trials<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 打印最佳结果 ---</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">贝叶斯优化完成!"</span>)</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"迭代次数 (Number of finished trials): </span><span class="sc">{</span><span class="bu">len</span>(study.trials)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"找到的最佳超参数组合 (Best Parameters): </span><span class="ch">\n</span><span class="sc">{</span>study<span class="sc">.</span>best_params<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">使用最佳参数时，模型的最佳平均 AUC 分数是: </span><span class="sc">{</span>study<span class="sc">.</span>best_value<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>[I 2025-09-12 12:06:24,092] A new study created in memory with name: RF_Optimization</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>

--- 最智能的调优方法二: 贝叶斯优化 (Bayesian Optimization with Optuna) ---
Optuna 会根据历史结果，智能地选择下一次要尝试的超参数...</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>[I 2025-09-12 12:06:26,062] Trial 0 finished with value: 0.7975024428376002 and parameters: {'n_estimators': 662, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 0 with value: 0.7975024428376002.
[I 2025-09-12 12:06:28,401] Trial 1 finished with value: 0.7987354124860382 and parameters: {'n_estimators': 758, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 1 with value: 0.7987354124860382.
[I 2025-09-12 12:06:30,359] Trial 2 finished with value: 0.7962259708194112 and parameters: {'n_estimators': 547, 'max_depth': 6, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 1 with value: 0.7987354124860382.
[I 2025-09-12 12:06:32,669] Trial 3 finished with value: 0.7951182333398477 and parameters: {'n_estimators': 588, 'max_depth': 9, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 1 with value: 0.7987354124860382.
[I 2025-09-12 12:06:34,517] Trial 4 finished with value: 0.795039522331905 and parameters: {'n_estimators': 507, 'max_depth': 10, 'min_samples_leaf': 7, 'max_features': 'log2'}. Best is trial 1 with value: 0.7987354124860382.
[I 2025-09-12 12:06:35,368] Trial 5 finished with value: 0.7947395657071677 and parameters: {'n_estimators': 226, 'max_depth': 8, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 1 with value: 0.7987354124860382.
[I 2025-09-12 12:06:38,438] Trial 6 finished with value: 0.7902455071648625 and parameters: {'n_estimators': 786, 'max_depth': 9, 'min_samples_leaf': 3, 'max_features': 'sqrt'}. Best is trial 1 with value: 0.7987354124860382.
[I 2025-09-12 12:06:40,595] Trial 7 finished with value: 0.7979688301866407 and parameters: {'n_estimators': 642, 'max_depth': 5, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 1 with value: 0.7987354124860382.
[I 2025-09-12 12:06:41,723] Trial 8 finished with value: 0.7974651369339568 and parameters: {'n_estimators': 334, 'max_depth': 5, 'min_samples_leaf': 4, 'max_features': 'sqrt'}. Best is trial 1 with value: 0.7987354124860382.
[I 2025-09-12 12:06:43,010] Trial 9 finished with value: 0.796392687534458 and parameters: {'n_estimators': 358, 'max_depth': 6, 'min_samples_leaf': 4, 'max_features': 'sqrt'}. Best is trial 1 with value: 0.7987354124860382.
[I 2025-09-12 12:06:45,395] Trial 10 finished with value: 0.7988974262421928 and parameters: {'n_estimators': 794, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 10 with value: 0.7988974262421928.
[I 2025-09-12 12:06:47,759] Trial 11 finished with value: 0.7989554982514845 and parameters: {'n_estimators': 780, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 11 with value: 0.7989554982514845.
[I 2025-09-12 12:06:50,104] Trial 12 finished with value: 0.7962377123282666 and parameters: {'n_estimators': 718, 'max_depth': 4, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 11 with value: 0.7989554982514845.
[I 2025-09-12 12:06:52,505] Trial 13 finished with value: 0.7991797308827104 and parameters: {'n_estimators': 784, 'max_depth': 3, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:06:54,654] Trial 14 finished with value: 0.7985183455117725 and parameters: {'n_estimators': 676, 'max_depth': 4, 'min_samples_leaf': 10, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:06:56,302] Trial 15 finished with value: 0.7961692652103383 and parameters: {'n_estimators': 433, 'max_depth': 7, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:06:58,239] Trial 16 finished with value: 0.7980679736443641 and parameters: {'n_estimators': 594, 'max_depth': 4, 'min_samples_leaf': 6, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:00,746] Trial 17 finished with value: 0.7981055178736269 and parameters: {'n_estimators': 733, 'max_depth': 5, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:02,854] Trial 18 finished with value: 0.7987934368302058 and parameters: {'n_estimators': 708, 'max_depth': 3, 'min_samples_leaf': 2, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:04,519] Trial 19 finished with value: 0.7927481803838949 and parameters: {'n_estimators': 446, 'max_depth': 7, 'min_samples_leaf': 6, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:06,439] Trial 20 finished with value: 0.7965123746605846 and parameters: {'n_estimators': 602, 'max_depth': 4, 'min_samples_leaf': 3, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:08,722] Trial 21 finished with value: 0.7984538545991284 and parameters: {'n_estimators': 772, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:11,054] Trial 22 finished with value: 0.7986725898527307 and parameters: {'n_estimators': 796, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:13,320] Trial 23 finished with value: 0.7970167670017525 and parameters: {'n_estimators': 699, 'max_depth': 4, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:16,033] Trial 24 finished with value: 0.7969568360526286 and parameters: {'n_estimators': 796, 'max_depth': 5, 'min_samples_leaf': 3, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:17,950] Trial 25 finished with value: 0.797897348389157 and parameters: {'n_estimators': 647, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:20,310] Trial 26 finished with value: 0.7973571436515616 and parameters: {'n_estimators': 741, 'max_depth': 4, 'min_samples_leaf': 2, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:22,519] Trial 27 finished with value: 0.7985077797426401 and parameters: {'n_estimators': 750, 'max_depth': 3, 'min_samples_leaf': 3, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:24,958] Trial 28 finished with value: 0.7962730480734551 and parameters: {'n_estimators': 696, 'max_depth': 6, 'min_samples_leaf': 5, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:26,896] Trial 29 finished with value: 0.7975611186051278 and parameters: {'n_estimators': 663, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:29,090] Trial 30 finished with value: 0.7983943844128689 and parameters: {'n_estimators': 639, 'max_depth': 5, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:31,244] Trial 31 finished with value: 0.7985672499288995 and parameters: {'n_estimators': 730, 'max_depth': 3, 'min_samples_leaf': 2, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:33,451] Trial 32 finished with value: 0.7985686481058675 and parameters: {'n_estimators': 750, 'max_depth': 3, 'min_samples_leaf': 2, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:36,126] Trial 33 finished with value: 0.7973512808413212 and parameters: {'n_estimators': 796, 'max_depth': 4, 'min_samples_leaf': 1, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:38,171] Trial 34 finished with value: 0.7982323229915902 and parameters: {'n_estimators': 701, 'max_depth': 3, 'min_samples_leaf': 3, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:40,563] Trial 35 finished with value: 0.7973017250008342 and parameters: {'n_estimators': 758, 'max_depth': 4, 'min_samples_leaf': 2, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:42,078] Trial 36 finished with value: 0.7977246258684982 and parameters: {'n_estimators': 516, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:43,696] Trial 37 finished with value: 0.7977758023231981 and parameters: {'n_estimators': 550, 'max_depth': 3, 'min_samples_leaf': 5, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:46,833] Trial 38 finished with value: 0.7908430848232657 and parameters: {'n_estimators': 769, 'max_depth': 10, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:48,996] Trial 39 finished with value: 0.7970188166020804 and parameters: {'n_estimators': 683, 'max_depth': 4, 'min_samples_leaf': 3, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:50,032] Trial 40 finished with value: 0.7949377414039922 and parameters: {'n_estimators': 259, 'max_depth': 9, 'min_samples_leaf': 2, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:52,125] Trial 41 finished with value: 0.7978447260923656 and parameters: {'n_estimators': 714, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:54,374] Trial 42 finished with value: 0.7986793424119506 and parameters: {'n_estimators': 766, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:56,335] Trial 43 finished with value: 0.7959593162279092 and parameters: {'n_estimators': 617, 'max_depth': 4, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:07:59,169] Trial 44 finished with value: 0.7920274360453199 and parameters: {'n_estimators': 723, 'max_depth': 8, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:01,582] Trial 45 finished with value: 0.7984456561978167 and parameters: {'n_estimators': 800, 'max_depth': 3, 'min_samples_leaf': 3, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:04,281] Trial 46 finished with value: 0.798224410581022 and parameters: {'n_estimators': 770, 'max_depth': 5, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:06,043] Trial 47 finished with value: 0.797908803907269 and parameters: {'n_estimators': 557, 'max_depth': 4, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:08,444] Trial 48 finished with value: 0.7954266108031415 and parameters: {'n_estimators': 678, 'max_depth': 8, 'min_samples_leaf': 7, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:10,962] Trial 49 finished with value: 0.7985558897410353 and parameters: {'n_estimators': 739, 'max_depth': 5, 'min_samples_leaf': 1, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:13,510] Trial 50 finished with value: 0.7984145944254049 and parameters: {'n_estimators': 781, 'max_depth': 4, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:15,836] Trial 51 finished with value: 0.7986233200029871 and parameters: {'n_estimators': 767, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:17,925] Trial 52 finished with value: 0.7979007485013291 and parameters: {'n_estimators': 713, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:20,189] Trial 53 finished with value: 0.7986760376300264 and parameters: {'n_estimators': 774, 'max_depth': 3, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:22,379] Trial 54 finished with value: 0.7982296696330262 and parameters: {'n_estimators': 746, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:23,807] Trial 55 finished with value: 0.7959633200983173 and parameters: {'n_estimators': 448, 'max_depth': 4, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:26,099] Trial 56 finished with value: 0.7989554982514845 and parameters: {'n_estimators': 780, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:27,258] Trial 57 finished with value: 0.7975624214518479 and parameters: {'n_estimators': 381, 'max_depth': 3, 'min_samples_leaf': 3, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:29,353] Trial 58 finished with value: 0.7961802917423351 and parameters: {'n_estimators': 658, 'max_depth': 4, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:31,678] Trial 59 finished with value: 0.797187630582579 and parameters: {'n_estimators': 735, 'max_depth': 4, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:34,000] Trial 60 finished with value: 0.798616567443767 and parameters: {'n_estimators': 790, 'max_depth': 3, 'min_samples_leaf': 3, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:36,296] Trial 61 finished with value: 0.7987354124860382 and parameters: {'n_estimators': 758, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:38,348] Trial 62 finished with value: 0.7978979998125172 and parameters: {'n_estimators': 700, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:41,160] Trial 63 finished with value: 0.7944944398632965 and parameters: {'n_estimators': 754, 'max_depth': 7, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:43,446] Trial 64 finished with value: 0.7989554982514845 and parameters: {'n_estimators': 780, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:45,962] Trial 65 finished with value: 0.7978601854808856 and parameters: {'n_estimators': 800, 'max_depth': 4, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:48,085] Trial 66 finished with value: 0.7982924446012097 and parameters: {'n_estimators': 723, 'max_depth': 3, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:50,377] Trial 67 finished with value: 0.7991790317942264 and parameters: {'n_estimators': 783, 'max_depth': 3, 'min_samples_leaf': 2, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:52,708] Trial 68 finished with value: 0.7991797308827104 and parameters: {'n_estimators': 784, 'max_depth': 3, 'min_samples_leaf': 2, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:54,965] Trial 69 finished with value: 0.7989533533209088 and parameters: {'n_estimators': 779, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:57,231] Trial 70 finished with value: 0.7991207691244393 and parameters: {'n_estimators': 783, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:08:59,495] Trial 71 finished with value: 0.7988945822231333 and parameters: {'n_estimators': 781, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:09:01,790] Trial 72 finished with value: 0.7991228187247673 and parameters: {'n_estimators': 786, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:09:04,018] Trial 73 finished with value: 0.7979473649925086 and parameters: {'n_estimators': 744, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:09:06,283] Trial 74 finished with value: 0.7988433104381855 and parameters: {'n_estimators': 777, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:09:08,743] Trial 75 finished with value: 0.7968341619120706 and parameters: {'n_estimators': 728, 'max_depth': 6, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:09:11,133] Trial 76 finished with value: 0.7989633153318049 and parameters: {'n_estimators': 757, 'max_depth': 4, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:09:13,504] Trial 77 finished with value: 0.7990173358055644 and parameters: {'n_estimators': 754, 'max_depth': 4, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:09:16,033] Trial 78 finished with value: 0.7980208010600724 and parameters: {'n_estimators': 757, 'max_depth': 5, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:09:18,217] Trial 79 finished with value: 0.7984650241264969 and parameters: {'n_estimators': 692, 'max_depth': 4, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 13 with value: 0.7991797308827104.
[I 2025-09-12 12:09:19,009] Trial 80 finished with value: 0.7998832839999301 and parameters: {'n_estimators': 249, 'max_depth': 4, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 80 with value: 0.7998832839999301.
[I 2025-09-12 12:09:20,085] Trial 81 finished with value: 0.7987002832897196 and parameters: {'n_estimators': 340, 'max_depth': 4, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 80 with value: 0.7998832839999301.
[I 2025-09-12 12:09:20,780] Trial 82 finished with value: 0.7999420074325816 and parameters: {'n_estimators': 217, 'max_depth': 4, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 82 with value: 0.7999420074325816.
[I 2025-09-12 12:09:21,444] Trial 83 finished with value: 0.79937963841237 and parameters: {'n_estimators': 205, 'max_depth': 4, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 82 with value: 0.7999420074325816.
[I 2025-09-12 12:09:22,218] Trial 84 finished with value: 0.8005951467370839 and parameters: {'n_estimators': 230, 'max_depth': 5, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 84 with value: 0.8005951467370839.
[I 2025-09-12 12:09:22,923] Trial 85 finished with value: 0.8010832852710001 and parameters: {'n_estimators': 209, 'max_depth': 5, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 85 with value: 0.8010832852710001.
[I 2025-09-12 12:09:23,606] Trial 86 finished with value: 0.8007435600445509 and parameters: {'n_estimators': 205, 'max_depth': 5, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 85 with value: 0.8010832852710001.
[I 2025-09-12 12:09:24,289] Trial 87 finished with value: 0.8028189630928946 and parameters: {'n_estimators': 203, 'max_depth': 5, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 87 with value: 0.8028189630928946.
[I 2025-09-12 12:09:25,005] Trial 88 finished with value: 0.8034329375539212 and parameters: {'n_estimators': 212, 'max_depth': 5, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 88 with value: 0.8034329375539212.
[I 2025-09-12 12:09:25,691] Trial 89 finished with value: 0.8029850283845812 and parameters: {'n_estimators': 200, 'max_depth': 5, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 88 with value: 0.8034329375539212.
[I 2025-09-12 12:09:26,379] Trial 90 finished with value: 0.8031572424772518 and parameters: {'n_estimators': 202, 'max_depth': 5, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 88 with value: 0.8034329375539212.
[I 2025-09-12 12:09:27,084] Trial 91 finished with value: 0.8037109999984111 and parameters: {'n_estimators': 209, 'max_depth': 5, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 91 with value: 0.8037109999984111.
[I 2025-09-12 12:09:27,963] Trial 92 finished with value: 0.7980920445319364 and parameters: {'n_estimators': 254, 'max_depth': 6, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 91 with value: 0.8037109999984111.
[I 2025-09-12 12:09:28,780] Trial 93 finished with value: 0.8030499482833406 and parameters: {'n_estimators': 244, 'max_depth': 5, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 91 with value: 0.8037109999984111.
[I 2025-09-12 12:09:29,726] Trial 94 finished with value: 0.8021223373070159 and parameters: {'n_estimators': 281, 'max_depth': 5, 'min_samples_leaf': 7, 'max_features': 'sqrt'}. Best is trial 91 with value: 0.8037109999984111.
[I 2025-09-12 12:09:30,681] Trial 95 finished with value: 0.8022945037345626 and parameters: {'n_estimators': 284, 'max_depth': 5, 'min_samples_leaf': 7, 'max_features': 'sqrt'}. Best is trial 91 with value: 0.8037109999984111.
[I 2025-09-12 12:09:31,655] Trial 96 finished with value: 0.8024038951939255 and parameters: {'n_estimators': 287, 'max_depth': 5, 'min_samples_leaf': 7, 'max_features': 'sqrt'}. Best is trial 91 with value: 0.8037109999984111.
[I 2025-09-12 12:09:32,636] Trial 97 finished with value: 0.8022310773430188 and parameters: {'n_estimators': 291, 'max_depth': 5, 'min_samples_leaf': 7, 'max_features': 'sqrt'}. Best is trial 91 with value: 0.8037109999984111.
[I 2025-09-12 12:09:33,649] Trial 98 finished with value: 0.7965552573837249 and parameters: {'n_estimators': 291, 'max_depth': 6, 'min_samples_leaf': 7, 'max_features': 'sqrt'}. Best is trial 91 with value: 0.8037109999984111.
[I 2025-09-12 12:09:34,614] Trial 99 finished with value: 0.802574059686268 and parameters: {'n_estimators': 286, 'max_depth': 5, 'min_samples_leaf': 7, 'max_features': 'sqrt'}. Best is trial 91 with value: 0.8037109999984111.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
贝叶斯优化完成!
迭代次数 (Number of finished trials): 100
找到的最佳超参数组合 (Best Parameters): 
{'n_estimators': 209, 'max_depth': 5, 'min_samples_leaf': 8, 'max_features': 'sqrt'}

使用最佳参数时，模型的最佳平均 AUC 分数是: 0.8037</code></pre>
</div>
</div>
<p>使用最佳参数时，模型的最佳平均 AUC 分数是: 0.8042(差不多远行了好几次的最好数据),这是迭代只有100次，但是也可以多迭代，设置到200，500等等，只要你的计算机能抗住。</p>
</section>
<section id="最终优化结合特征选择与贝叶斯调优" class="level3">
<h3 class="anchored" data-anchor-id="最终优化结合特征选择与贝叶斯调优">最终优化：结合特征选择与贝叶斯调优🤤</h3>
<p><strong>目标</strong>： 在我们已经验证过的“最佳特征集”（最重要的10个特征）上，使用贝叶斯优化（Optuna）来寻找最优的超参数组合，从而获得理论上性能最好的模型</p>
<div id="820c1fb2" class="cell" data-execution_count="16">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 导入所有需要的库</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optuna</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> cross_val_score</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> RandomForestClassifier</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1. 最终步骤一：确定并筛选出最佳特征集 (Top 10) ---</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co"># The first step of our final process: identify and select the best feature set.</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="co"># !!! 重要提示: 请将下面的路径修改为您保存 CSV 文件的实际位置 !!!</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> <span class="st">"./synthetic_schizophrenia_data.csv"</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(file_path)</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'High_SWB'</span>] <span class="op">=</span> (df[<span class="st">'SWN_Total_Score'</span>] <span class="op">&gt;=</span> <span class="dv">80</span>).astype(<span class="bu">int</span>)</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> df.drop([<span class="st">'SWN_Total_Score'</span>, <span class="st">'High_SWB'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> df[<span class="st">'High_SWB'</span>]</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> pd.get_dummies(X, columns<span class="op">=</span>[<span class="st">'Education'</span>], drop_first<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a><span class="co"># 训练一个临时模型来获取特征重要性</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>temp_rf <span class="op">=</span> RandomForestClassifier(n_estimators<span class="op">=</span><span class="dv">500</span>, max_depth<span class="op">=</span><span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>, )</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>temp_rf.fit(X, y)</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a><span class="co"># 获取最重要的10个特征的名称</span></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>N_TOP_FEATURES <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>feature_importances <span class="op">=</span> pd.DataFrame({</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>    <span class="st">'feature'</span>: X.columns,</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>    <span class="st">'importance'</span>: temp_rf.feature_importances_</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>}).sort_values(<span class="st">'importance'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>top_10_features <span class="op">=</span> feature_importances[<span class="st">'feature'</span>].head(N_TOP_FEATURES).tolist()</span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建只包含这10个特征的新数据集</span></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>X_top10 <span class="op">=</span> X[top_10_features]</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"--- 最终优化流程 ---"</span>)</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"已成功筛选出最重要的 </span><span class="sc">{</span>N_TOP_FEATURES<span class="sc">}</span><span class="ss"> 个特征用于最终调优:"</span>)</span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(top_10_features)</span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 2. 最终步骤二：在最佳特征集上进行贝叶斯优化 ---</span></span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a><span class="co"># The second step: run Bayesian Optimization on this optimal feature set.</span></span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">现在，我们只在这10个特征上进行贝叶斯优化 (Optuna)..."</span>)</span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a><span class="co"># 定义目标函数，与之前类似，但这次使用的是筛选后的数据</span></span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> objective_top10(trial):</span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 定义超参数搜索空间</span></span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>    params <span class="op">=</span> {</span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a>        <span class="st">'n_estimators'</span>: trial.suggest_int(<span class="st">'n_estimators'</span>, <span class="dv">200</span>, <span class="dv">800</span>),</span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a>        <span class="st">'max_depth'</span>: trial.suggest_int(<span class="st">'max_depth'</span>, <span class="dv">3</span>, <span class="dv">10</span>),</span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a>        <span class="st">'min_samples_leaf'</span>: trial.suggest_int(<span class="st">'min_samples_leaf'</span>, <span class="dv">1</span>, <span class="dv">10</span>),</span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a>        <span class="st">'max_features'</span>: trial.suggest_categorical(<span class="st">'max_features'</span>, [<span class="st">'sqrt'</span>, <span class="st">'log2'</span>]),</span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> RandomForestClassifier(random_state<span class="op">=</span><span class="dv">42</span>, <span class="op">**</span>params)</span>
<span id="cb30-57"><a href="#cb30-57" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-58"><a href="#cb30-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ！！！ 关键不同点 ！！！</span></span>
<span id="cb30-59"><a href="#cb30-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 注意：我们在这里使用 X_top10，而不是完整的 X</span></span>
<span id="cb30-60"><a href="#cb30-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CRITICAL DIFFERENCE: We are using X_top10 here, not the full X.</span></span>
<span id="cb30-61"><a href="#cb30-61" aria-hidden="true" tabindex="-1"></a>    score <span class="op">=</span> cross_val_score(model, X_top10, y, cv<span class="op">=</span><span class="dv">5</span>, scoring<span class="op">=</span><span class="st">'roc_auc'</span>).mean()</span>
<span id="cb30-62"><a href="#cb30-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-63"><a href="#cb30-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> score</span>
<span id="cb30-64"><a href="#cb30-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-65"><a href="#cb30-65" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建一个新的 "研究" (Study)</span></span>
<span id="cb30-66"><a href="#cb30-66" aria-hidden="true" tabindex="-1"></a>study_top10 <span class="op">=</span> optuna.create_study(direction<span class="op">=</span><span class="st">'maximize'</span>, study_name<span class="op">=</span><span class="st">'RF_Top10_Optimization'</span>)</span>
<span id="cb30-67"><a href="#cb30-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-68"><a href="#cb30-68" aria-hidden="true" tabindex="-1"></a><span class="co"># 运行优化，n_trials 可以根据需要调整</span></span>
<span id="cb30-69"><a href="#cb30-69" aria-hidden="true" tabindex="-1"></a>study_top10.optimize(objective_top10, n_trials<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb30-70"><a href="#cb30-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-71"><a href="#cb30-71" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 打印最终优化结果 ---</span></span>
<span id="cb30-72"><a href="#cb30-72" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the final optimization results</span></span>
<span id="cb30-73"><a href="#cb30-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-74"><a href="#cb30-74" aria-hidden="true" tabindex="-1"></a>best_params_top10 <span class="op">=</span> study_top10.best_params</span>
<span id="cb30-75"><a href="#cb30-75" aria-hidden="true" tabindex="-1"></a>best_score_top10 <span class="op">=</span> study_top10.best_value</span>
<span id="cb30-76"><a href="#cb30-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-77"><a href="#cb30-77" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">在Top 10特征集上的贝叶斯优化完成!"</span>)</span>
<span id="cb30-78"><a href="#cb30-78" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"找到的最佳超参数组合 (Best Parameters): </span><span class="ch">\n</span><span class="sc">{</span>best_params_top10<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb30-79"><a href="#cb30-79" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">最终模型的最佳平均 AUC 分数是: </span><span class="sc">{</span>best_score_top10<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb30-80"><a href="#cb30-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-81"><a href="#cb30-81" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 4. 训练最终的、最优化的模型 ---</span></span>
<span id="cb30-82"><a href="#cb30-82" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the final, most optimized model</span></span>
<span id="cb30-83"><a href="#cb30-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-84"><a href="#cb30-84" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">正在使用找到的最佳特征和最佳超参数来训练最终模型..."</span>)</span>
<span id="cb30-85"><a href="#cb30-85" aria-hidden="true" tabindex="-1"></a>final_model <span class="op">=</span> RandomForestClassifier(random_state<span class="op">=</span><span class="dv">42</span>,  <span class="op">**</span>best_params_top10)</span>
<span id="cb30-86"><a href="#cb30-86" aria-hidden="true" tabindex="-1"></a>final_model.fit(X_top10, y)</span>
<span id="cb30-87"><a href="#cb30-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-88"><a href="#cb30-88" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"最终模型训练完成！这个模型是我们整个分析过程的最终成果。"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>[I 2025-09-12 12:09:35,006] A new study created in memory with name: RF_Top10_Optimization</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>--- 最终优化流程 ---
已成功筛选出最重要的 10 个特征用于最终调优:
['SCL90R_OCS', 'CGI_Depressive', 'SCL90R_Somatization', 'PSP_Total_Score', 'CGI_Negative', 'Duration_of_Illness', 'CGI_Positive', 'CGI_Cognitive', 'Age', 'DIEPSS_Overall_Severity']

现在，我们只在这10个特征上进行贝叶斯优化 (Optuna)...</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>[I 2025-09-12 12:09:37,678] Trial 0 finished with value: 0.7974902882310043 and parameters: {'n_estimators': 709, 'max_depth': 7, 'min_samples_leaf': 5, 'max_features': 'log2'}. Best is trial 0 with value: 0.7974902882310043.
[I 2025-09-12 12:09:38,587] Trial 1 finished with value: 0.8014817339301008 and parameters: {'n_estimators': 271, 'max_depth': 4, 'min_samples_leaf': 2, 'max_features': 'sqrt'}. Best is trial 1 with value: 0.8014817339301008.
[I 2025-09-12 12:09:39,567] Trial 2 finished with value: 0.8006315628917478 and parameters: {'n_estimators': 293, 'max_depth': 4, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 1 with value: 0.8014817339301008.
[I 2025-09-12 12:09:40,647] Trial 3 finished with value: 0.8014801450926372 and parameters: {'n_estimators': 322, 'max_depth': 4, 'min_samples_leaf': 1, 'max_features': 'log2'}. Best is trial 1 with value: 0.8014817339301008.
[I 2025-09-12 12:09:41,512] Trial 4 finished with value: 0.7991735820817267 and parameters: {'n_estimators': 222, 'max_depth': 9, 'min_samples_leaf': 5, 'max_features': 'log2'}. Best is trial 1 with value: 0.8014817339301008.
[I 2025-09-12 12:09:44,209] Trial 5 finished with value: 0.7990501135224367 and parameters: {'n_estimators': 748, 'max_depth': 7, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 1 with value: 0.8014817339301008.
[I 2025-09-12 12:09:45,970] Trial 6 finished with value: 0.7985547616664362 and parameters: {'n_estimators': 502, 'max_depth': 5, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 1 with value: 0.8014817339301008.
[I 2025-09-12 12:09:46,889] Trial 7 finished with value: 0.7994638309095616 and parameters: {'n_estimators': 258, 'max_depth': 5, 'min_samples_leaf': 3, 'max_features': 'log2'}. Best is trial 1 with value: 0.8014817339301008.
[I 2025-09-12 12:09:48,505] Trial 8 finished with value: 0.799350769235658 and parameters: {'n_estimators': 436, 'max_depth': 7, 'min_samples_leaf': 7, 'max_features': 'sqrt'}. Best is trial 1 with value: 0.8014817339301008.
[I 2025-09-12 12:09:51,306] Trial 9 finished with value: 0.7988488554809331 and parameters: {'n_estimators': 781, 'max_depth': 5, 'min_samples_leaf': 1, 'max_features': 'sqrt'}. Best is trial 1 with value: 0.8014817339301008.
[I 2025-09-12 12:09:52,952] Trial 10 finished with value: 0.8026295736672434 and parameters: {'n_estimators': 545, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:09:54,757] Trial 11 finished with value: 0.8025121268019404 and parameters: {'n_estimators': 597, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:09:56,509] Trial 12 finished with value: 0.8025114277134563 and parameters: {'n_estimators': 583, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:09:58,411] Trial 13 finished with value: 0.8019518073820567 and parameters: {'n_estimators': 634, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:00,327] Trial 14 finished with value: 0.7980027677548615 and parameters: {'n_estimators': 496, 'max_depth': 10, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:02,236] Trial 15 finished with value: 0.802179201799835 and parameters: {'n_estimators': 613, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:03,651] Trial 16 finished with value: 0.7990156039727292 and parameters: {'n_estimators': 396, 'max_depth': 6, 'min_samples_leaf': 7, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:05,581] Trial 17 finished with value: 0.7979236913143022 and parameters: {'n_estimators': 545, 'max_depth': 8, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:07,601] Trial 18 finished with value: 0.8022298698265466 and parameters: {'n_estimators': 671, 'max_depth': 3, 'min_samples_leaf': 7, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:08,972] Trial 19 finished with value: 0.798337599361923 and parameters: {'n_estimators': 388, 'max_depth': 6, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:10,729] Trial 20 finished with value: 0.8015777156012718 and parameters: {'n_estimators': 536, 'max_depth': 4, 'min_samples_leaf': 6, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:12,487] Trial 21 finished with value: 0.8024547062160087 and parameters: {'n_estimators': 585, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:14,451] Trial 22 finished with value: 0.8019002496063656 and parameters: {'n_estimators': 654, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:16,000] Trial 23 finished with value: 0.8007322951869347 and parameters: {'n_estimators': 479, 'max_depth': 4, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:17,927] Trial 24 finished with value: 0.7993457802860224 and parameters: {'n_estimators': 562, 'max_depth': 5, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:20,111] Trial 25 finished with value: 0.8017842962482782 and parameters: {'n_estimators': 698, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:22,078] Trial 26 finished with value: 0.800559477336028 and parameters: {'n_estimators': 611, 'max_depth': 4, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 10 with value: 0.8026295736672434.
[I 2025-09-12 12:10:23,421] Trial 27 finished with value: 0.8026821959640351 and parameters: {'n_estimators': 443, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 27 with value: 0.8026821959640351.
[I 2025-09-12 12:10:24,684] Trial 28 finished with value: 0.8006787831411634 and parameters: {'n_estimators': 367, 'max_depth': 5, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 27 with value: 0.8026821959640351.
[I 2025-09-12 12:10:26,289] Trial 29 finished with value: 0.7973467049894263 and parameters: {'n_estimators': 444, 'max_depth': 6, 'min_samples_leaf': 6, 'max_features': 'sqrt'}. Best is trial 27 with value: 0.8026821959640351.
[I 2025-09-12 12:10:27,720] Trial 30 finished with value: 0.8015735687354919 and parameters: {'n_estimators': 441, 'max_depth': 4, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 27 with value: 0.8026821959640351.
[I 2025-09-12 12:10:29,317] Trial 31 finished with value: 0.8027416184851706 and parameters: {'n_estimators': 530, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 31 with value: 0.8027416184851706.
[I 2025-09-12 12:10:30,882] Trial 32 finished with value: 0.8024012418353615 and parameters: {'n_estimators': 517, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'sqrt'}. Best is trial 31 with value: 0.8027416184851706.
[I 2025-09-12 12:10:32,395] Trial 33 finished with value: 0.8017477370982424 and parameters: {'n_estimators': 465, 'max_depth': 4, 'min_samples_leaf': 8, 'max_features': 'sqrt'}. Best is trial 31 with value: 0.8027416184851706.
[I 2025-09-12 12:10:34,256] Trial 34 finished with value: 0.8003893605088093 and parameters: {'n_estimators': 573, 'max_depth': 4, 'min_samples_leaf': 10, 'max_features': 'sqrt'}. Best is trial 31 with value: 0.8027416184851706.
[I 2025-09-12 12:10:35,841] Trial 35 finished with value: 0.8027395688848425 and parameters: {'n_estimators': 526, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 31 with value: 0.8027416184851706.
[I 2025-09-12 12:10:36,969] Trial 36 finished with value: 0.8030340281319562 and parameters: {'n_estimators': 336, 'max_depth': 4, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 36 with value: 0.8030340281319562.
[I 2025-09-12 12:10:38,038] Trial 37 finished with value: 0.8030425919658845 and parameters: {'n_estimators': 326, 'max_depth': 4, 'min_samples_leaf': 7, 'max_features': 'log2'}. Best is trial 37 with value: 0.8030425919658845.
[I 2025-09-12 12:10:39,100] Trial 38 finished with value: 0.80309461050444 and parameters: {'n_estimators': 324, 'max_depth': 4, 'min_samples_leaf': 7, 'max_features': 'log2'}. Best is trial 38 with value: 0.80309461050444.
[I 2025-09-12 12:10:40,241] Trial 39 finished with value: 0.799110981885664 and parameters: {'n_estimators': 325, 'max_depth': 5, 'min_samples_leaf': 5, 'max_features': 'log2'}. Best is trial 38 with value: 0.80309461050444.
[I 2025-09-12 12:10:41,059] Trial 40 finished with value: 0.797393972903966 and parameters: {'n_estimators': 214, 'max_depth': 8, 'min_samples_leaf': 6, 'max_features': 'log2'}. Best is trial 38 with value: 0.80309461050444.
[I 2025-09-12 12:10:42,049] Trial 41 finished with value: 0.8029259395193131 and parameters: {'n_estimators': 296, 'max_depth': 4, 'min_samples_leaf': 7, 'max_features': 'log2'}. Best is trial 38 with value: 0.80309461050444.
[I 2025-09-12 12:10:42,992] Trial 42 finished with value: 0.8025842600227839 and parameters: {'n_estimators': 279, 'max_depth': 4, 'min_samples_leaf': 7, 'max_features': 'log2'}. Best is trial 38 with value: 0.80309461050444.
[I 2025-09-12 12:10:44,166] Trial 43 finished with value: 0.7979568503521658 and parameters: {'n_estimators': 314, 'max_depth': 5, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 38 with value: 0.80309461050444.
[I 2025-09-12 12:10:44,999] Trial 44 finished with value: 0.8026418712692112 and parameters: {'n_estimators': 250, 'max_depth': 4, 'min_samples_leaf': 7, 'max_features': 'log2'}. Best is trial 38 with value: 0.80309461050444.
[I 2025-09-12 12:10:46,195] Trial 45 finished with value: 0.8011576110875435 and parameters: {'n_estimators': 342, 'max_depth': 5, 'min_samples_leaf': 6, 'max_features': 'log2'}. Best is trial 38 with value: 0.80309461050444.
[I 2025-09-12 12:10:47,015] Trial 46 finished with value: 0.8033251825971455 and parameters: {'n_estimators': 244, 'max_depth': 4, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:10:47,901] Trial 47 finished with value: 0.7975646934894207 and parameters: {'n_estimators': 240, 'max_depth': 5, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:10:49,013] Trial 48 finished with value: 0.7981127788608353 and parameters: {'n_estimators': 294, 'max_depth': 6, 'min_samples_leaf': 3, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:10:50,275] Trial 49 finished with value: 0.8000130761323249 and parameters: {'n_estimators': 358, 'max_depth': 5, 'min_samples_leaf': 5, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:10:51,239] Trial 50 finished with value: 0.8010956305380917 and parameters: {'n_estimators': 289, 'max_depth': 4, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:10:51,931] Trial 51 finished with value: 0.8011262315476388 and parameters: {'n_estimators': 206, 'max_depth': 4, 'min_samples_leaf': 3, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:10:53,237] Trial 52 finished with value: 0.8019321057975091 and parameters: {'n_estimators': 399, 'max_depth': 4, 'min_samples_leaf': 7, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:10:54,273] Trial 53 finished with value: 0.8028808165353493 and parameters: {'n_estimators': 313, 'max_depth': 4, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:10:55,207] Trial 54 finished with value: 0.79790157469681 and parameters: {'n_estimators': 264, 'max_depth': 5, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:10:56,410] Trial 55 finished with value: 0.7992486546518778 and parameters: {'n_estimators': 312, 'max_depth': 10, 'min_samples_leaf': 5, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:10:57,528] Trial 56 finished with value: 0.7999153785166933 and parameters: {'n_estimators': 336, 'max_depth': 4, 'min_samples_leaf': 2, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:10:58,413] Trial 57 finished with value: 0.7939838033908969 and parameters: {'n_estimators': 233, 'max_depth': 7, 'min_samples_leaf': 5, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:10:59,998] Trial 58 finished with value: 0.7960905065372718 and parameters: {'n_estimators': 415, 'max_depth': 6, 'min_samples_leaf': 3, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:11:00,978] Trial 59 finished with value: 0.8028706161988335 and parameters: {'n_estimators': 299, 'max_depth': 4, 'min_samples_leaf': 7, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:11:02,367] Trial 60 finished with value: 0.7986887959948585 and parameters: {'n_estimators': 369, 'max_depth': 8, 'min_samples_leaf': 6, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:11:03,353] Trial 61 finished with value: 0.8027565217805783 and parameters: {'n_estimators': 300, 'max_depth': 4, 'min_samples_leaf': 7, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:11:04,225] Trial 62 finished with value: 0.8017607337886942 and parameters: {'n_estimators': 265, 'max_depth': 4, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:11:05,399] Trial 63 finished with value: 0.8020949139723956 and parameters: {'n_estimators': 355, 'max_depth': 4, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:11:06,372] Trial 64 finished with value: 0.8008678071341981 and parameters: {'n_estimators': 278, 'max_depth': 5, 'min_samples_leaf': 6, 'max_features': 'log2'}. Best is trial 46 with value: 0.8033251825971455.
[I 2025-09-12 12:11:07,358] Trial 65 finished with value: 0.8037308445783304 and parameters: {'n_estimators': 323, 'max_depth': 3, 'min_samples_leaf': 7, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:08,376] Trial 66 finished with value: 0.8028496117675659 and parameters: {'n_estimators': 334, 'max_depth': 3, 'min_samples_leaf': 4, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:09,515] Trial 67 finished with value: 0.8031817900160633 and parameters: {'n_estimators': 377, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:10,677] Trial 68 finished with value: 0.8031838396163911 and parameters: {'n_estimators': 383, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:11,888] Trial 69 finished with value: 0.8032432621375266 and parameters: {'n_estimators': 401, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:13,046] Trial 70 finished with value: 0.8030710957099799 and parameters: {'n_estimators': 382, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:14,199] Trial 71 finished with value: 0.802961704250617 and parameters: {'n_estimators': 381, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:15,451] Trial 72 finished with value: 0.8027349135910746 and parameters: {'n_estimators': 413, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:16,687] Trial 73 finished with value: 0.8027929379352422 and parameters: {'n_estimators': 409, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:17,943] Trial 74 finished with value: 0.8034633955680966 and parameters: {'n_estimators': 386, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:19,269] Trial 75 finished with value: 0.8027976885592581 and parameters: {'n_estimators': 425, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:20,425] Trial 76 finished with value: 0.802961704250617 and parameters: {'n_estimators': 381, 'max_depth': 3, 'min_samples_leaf': 8, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:21,493] Trial 77 finished with value: 0.8033472038843898 and parameters: {'n_estimators': 353, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:22,903] Trial 78 finished with value: 0.802961005162133 and parameters: {'n_estimators': 466, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:24,004] Trial 79 finished with value: 0.8034598524605532 and parameters: {'n_estimators': 364, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:25,125] Trial 80 finished with value: 0.8035132691760765 and parameters: {'n_estimators': 370, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:26,199] Trial 81 finished with value: 0.8033472038843898 and parameters: {'n_estimators': 353, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:27,270] Trial 82 finished with value: 0.8035166692882484 and parameters: {'n_estimators': 352, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:28,339] Trial 83 finished with value: 0.8035166692882484 and parameters: {'n_estimators': 352, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:29,415] Trial 84 finished with value: 0.8031216684064437 and parameters: {'n_estimators': 354, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:30,469] Trial 85 finished with value: 0.8032945339224742 and parameters: {'n_estimators': 347, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 65 with value: 0.8037308445783304.
[I 2025-09-12 12:11:31,578] Trial 86 finished with value: 0.8037974804215503 and parameters: {'n_estimators': 363, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 86 with value: 0.8037974804215503.
[I 2025-09-12 12:11:32,688] Trial 87 finished with value: 0.8037394560773828 and parameters: {'n_estimators': 367, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 86 with value: 0.8037974804215503.
[I 2025-09-12 12:11:33,800] Trial 88 finished with value: 0.8032297093539629 and parameters: {'n_estimators': 367, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'log2'}. Best is trial 86 with value: 0.8037974804215503.
[I 2025-09-12 12:11:35,173] Trial 89 finished with value: 0.8025173381888207 and parameters: {'n_estimators': 455, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 86 with value: 0.8037974804215503.
[I 2025-09-12 12:11:36,467] Trial 90 finished with value: 0.8026294306718716 and parameters: {'n_estimators': 428, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 86 with value: 0.8037974804215503.
[I 2025-09-12 12:11:37,563] Trial 91 finished with value: 0.8035200217352966 and parameters: {'n_estimators': 362, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 86 with value: 0.8037974804215503.
[I 2025-09-12 12:11:38,750] Trial 92 finished with value: 0.8026253791363398 and parameters: {'n_estimators': 393, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 86 with value: 0.8037974804215503.
[I 2025-09-12 12:11:39,863] Trial 93 finished with value: 0.8032297093539629 and parameters: {'n_estimators': 367, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'log2'}. Best is trial 86 with value: 0.8037974804215503.
[I 2025-09-12 12:11:40,899] Trial 94 finished with value: 0.803572739362336 and parameters: {'n_estimators': 341, 'max_depth': 3, 'min_samples_leaf': 9, 'max_features': 'log2'}. Best is trial 86 with value: 0.8037974804215503.
[I 2025-09-12 12:11:41,860] Trial 95 finished with value: 0.8043518893660696 and parameters: {'n_estimators': 316, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'log2'}. Best is trial 95 with value: 0.8043518893660696.
[I 2025-09-12 12:11:42,822] Trial 96 finished with value: 0.8036294131946595 and parameters: {'n_estimators': 314, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'log2'}. Best is trial 95 with value: 0.8043518893660696.
[I 2025-09-12 12:11:43,779] Trial 97 finished with value: 0.8041311045121395 and parameters: {'n_estimators': 315, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'log2'}. Best is trial 95 with value: 0.8043518893660696.
[I 2025-09-12 12:11:44,765] Trial 98 finished with value: 0.8039075709693974 and parameters: {'n_estimators': 325, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'log2'}. Best is trial 95 with value: 0.8043518893660696.
[I 2025-09-12 12:11:45,707] Trial 99 finished with value: 0.8032945339224742 and parameters: {'n_estimators': 310, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'log2'}. Best is trial 95 with value: 0.8043518893660696.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
在Top 10特征集上的贝叶斯优化完成!
找到的最佳超参数组合 (Best Parameters): 
{'n_estimators': 316, 'max_depth': 3, 'min_samples_leaf': 10, 'max_features': 'log2'}

最终模型的最佳平均 AUC 分数是: 0.8044

正在使用找到的最佳特征和最佳超参数来训练最终模型...
最终模型训练完成！这个模型是我们整个分析过程的最终成果。</code></pre>
</div>
</div>
<p>同样运行了好几次，得到了较好的数据，<strong><em>是最终模型的最佳平均 AUC 分数是: 0.8044</em></strong></p>
<p><strong><em>AUC 接近 0.805 通常意味着模型已经捕捉到了数据中大部分的可预测结构。这就是我们在机器学习中常说的“性能瓶颈”：再怎么调参、选特征，提升空间已经非常有限，这是我们随机森林的极限了，除非换一个更加适配这个数据的机器学习模型。</em></strong></p>
<p><strong><em>模型的性能上限，往往不是由算法决定的，而是由数据本身的可预测性决定的。 如果数据中没有更多“可解释的信号”，再复杂的模型也无法凭空创造预测能力。</em></strong></p>
<section id="概念引入性能天花板与不可约减误差-irreducible-error" class="level4">
<h4 class="anchored" data-anchor-id="概念引入性能天花板与不可约减误差-irreducible-error">1. 概念引入：性能天花板与不可约减误差 (Irreducible Error)🧉</h4>
<p>性能天花板（Performance Ceiling）。”</p>
<p><strong>核心知识点：</strong><br>
在机器学习中，一个模型的总误差可以被分解为两部分：</p>
<p><strong>总误差 = 可约减误差 (Reducible Error) + 不可约减误差 (Irreducible Error)</strong></p>
<ul>
<li><p><strong>可约减误差：</strong> 这是我们可以通过选择更好的模型、做特征工程、调优超参数来减少的部分。我们之前做的所有工作，都是在努力<strong>将这部分误差降到最低</strong>。</p></li>
<li><p><strong>不可约减误差：</strong> 这是数据本身固有的、无法被任何模型消除的“噪声”或不确定性。<strong>这个误差决定了我们性能天花板的高度。</strong></p></li>
<li><p><strong>打个比方 (Analogy):</strong><br>
这就像用麦克风录音。我们可以买更好的麦克风、调整录音棚的环境来减少背景噪音（降低<strong>可约减误差</strong>）。但是，声音本身的一些微小颤动、空气中的随机分子运动是无法被消除的（<strong>不可约减误差</strong>）。我们能做的，就是尽可能清晰地捕捉到“信号”，但我们无法消除所有的“噪声”。</p></li>
</ul>
</section>
<section id="教学总结当我们触及天花板时该做什么" class="level4">
<h4 class="anchored" data-anchor-id="教学总结当我们触及天花板时该做什么">教学总结：当我们触及天花板时，该做什么🤖？</h4>
<p>这是最关键的教学部分。当模型调优不再有效时，真正的数据科学家会从以下几个方面思考，这也是未来的工作方向：</p>
<p><strong>路径 A：获取更好的数据 (数据为中心 - The Data-Centric Approach)</strong><br>
这是<strong>最重要、最有效</strong>的路径。</p>
<ul>
<li><p><strong>行动：</strong> 与领域专家（精神科医生、心理学家）合作，讨论是否可以收集新的、可能与主观幸福感相关的数据。比如，在下一次研究中加入“社会支持量表”、“生活事件记录”等。</p></li>
<li><p><strong>结论：</strong> <strong>提升性能天花板的最好方法，是为模型提供更高信噪比、更丰富信息的数据。</strong></p></li>
</ul>
<p><strong>路径 B：尝试完全不同的模型 (模型为中心 - The Model-Centric Approach)</strong></p>
<ul>
<li><p><strong>行动：</strong> 我们已经证明了随机森林（一种基于决策树的集成模型）的极限。我们可以尝试结构完全不同的模型，比如：</p>
<ul>
<li><p><strong>深度学习/神经网络 (Deep Learning / Neural Networks):</strong> 如果有<strong><em>足够多的数据</em></strong>，神经网络能够捕捉到比树模型更高阶、更复杂的非线性关系。</p></li>
<li><p><strong>梯度提升机 (Gradient Boosting Machines):</strong> 我们可以对之前测试过的 XGBoost 或 LightGBM 模型进行同样深入的特征选择和贝叶斯优化，有时它们在特定数据集上的表现会略胜于随机森林。</p></li>
</ul></li>
<li><p><strong>结论：</strong> 换一个更强大的模型<strong>有可能</strong>会略微提升性能，但这通常是在数据质量已经很好的前提下。如果数据本身信息量有限，换模型也只是“锦上添花”，而不会有质的飞跃。</p></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="论文总结" class="level2">
<h2 class="anchored" data-anchor-id="论文总结">论文总结🤗</h2>
<p>this is what it is 没什么总结的，<strong>我们的机器学习得到了在我们测量的所有事物中，哪些与患者的主观幸福感最密切相关？即 OCS、躯体化、认知和抑郁是最重要的预测因素。我们确定了主要特征</strong></p>
<p><strong><em><code>这也是差不多你们要写的论文的机器学习的大概流程</code></em></strong></p>
<ul>
<li>但是如果看我们的复现论文，他们接下来的步骤是</li>
</ul>
<section id="step-1-network-analysis-网络分析" class="level3">
<h3 class="anchored" data-anchor-id="step-1-network-analysis-网络分析">Step 1: Network Analysis (网络分析)🫥</h3>
<p><strong>“为什么”（目的）：</strong><br>
机器学习告诉我们，强迫症症状、躯体化症状、抑郁症和认知是最重要的预测因素。但它并没有告诉我们它们是如何相互关联的。强迫症症状和躯体化症状是否高度相关？抑郁症是否是连接一切的中心枢纽？</p>
<p>网络分析帮助我们将症状的“生态系统”可视化。它将每个变量（症状、人口统计因素）视为一个“节点”（城市），并将它们之间的相关性视为一条“边”（高速公路）。相关性越强，高速公路就越粗。</p>
<p>论文中的图3）：</p>
<ul>
<li><p><strong>社群（群落）：</strong> 他们寻找的是节点之间的连接比与网络其他部分的连接更紧密的集群。在论文中，他们发现了一个关键模式：</p>
<ul>
<li><p><strong>社区 1：</strong> 主观幸福感（SWB）、强迫症</p></li>
<li><p><strong>社区 2：</strong> 精神病症状（阳性、阴性）、认知缺陷和社会心理功能 (PSP) 形成了另一个不同的集群。</p></li>
<li><p>幸福感的内在体验与强迫症和躯体系统更密切相关</p></li>
</ul></li>
<li><p><strong>中心性：</strong> 该指标用于识别网络中最具“影响力”的节点。论文指出， <strong>抑郁症</strong>的“中介中心性”最高。</p>
<ul>
<li><strong>这是什么意思？</strong> 这意味着抑郁症是连接两个群体的关键<strong>桥梁</strong> 。要从“精神病症状”群体走向“主观幸福感”群体，通常需要经过“抑郁症”这一环节。这表明抑郁症起着关键的中介作用。</li>
</ul></li>
</ul>
<p>这是一种可视化和探索性的工具。它从我们的机器学习模型中获取重要特征列表，并将其转化为地图。这张地图向我们展示了复杂症状网络的结构和关键因素，这让我们假设抑郁症是一个关键的中介因素。</p>
</section>
<section id="step-2-structural-equation-modeling-sem-结构方程模型" class="level3">
<h3 class="anchored" data-anchor-id="step-2-structural-equation-modeling-sem-结构方程模型">Step 2: Structural Equation Modeling (SEM) (结构方程模型)🍔</h3>
<p>方向或因果关系。它显示了两座城市之间的高速公路，但没有显示交通走向</p>
<p>看看论文中的图 4。这是他们的 SEM 分析结果。它就像一个流程图，展示了影响力的流动。</p>
<ul>
<li><p><strong>直接效应（直接效应）：</strong> 从一个变量到另一个变量的直线箭头。</p>
<ul>
<li>论文发现， <strong>强迫性行为对主观幸福感（SWB）的直接负面影响最为强烈</strong> （见粗红色箭头，系数为-0.59）。这是论文最重要的发现：高强迫性行为会直接摧毁患者的幸福感。</li>
</ul></li>
<li><p><strong>间接效应：</strong> 至少经过一个其他变量的路径。</p>
<ul>
<li><p>论文证实了抑郁症的“桥梁”作用。例如，阴性症状有一个箭头指向抑郁症，抑郁症也有一个箭头指向主观幸福感。这是一条<strong>间接路径</strong> 。这意味着阴性症状部分地通过增加抑郁来恶化主观幸福感 。</p></li>
<li><p>OCS 还通过抑郁症对 SWB 产生间接影响 。</p></li>
</ul></li>
</ul>
<p>SEM 是一种验证性工具，是分析的最终步骤，也是最有力的一步。它超越了“什么是重要的”（ML）和“它们如何关联”（网络分析）的范畴，从而检验了关于“什么导致什么”的特定理论。SEM 结果为本文的主要结论提供了最有力的证据：管理 OCS 对于改善精神分裂症患者的主观幸福感至关重要，这既是因为它强大的直接影响，也是因为它通过抑郁症产生的间接影响。</p>
</section>
</section>
</section>
<section id="我滴任务完成了" class="level1">
<h1>我滴任务完成了🛫</h1>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>