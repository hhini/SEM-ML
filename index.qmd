---
title: SEM + ML 实际项目论文复现
authors:
  - name: JAYZJAYZ
    affiliation: GAN NAN medical university
    roles: writing
    corresponding: true
bibliography: references.bib
---

# SEM加ML分析 🫥

------------------------------------------------------------------------

***要具体知道为什么要结合，可以参考文献 [混合人工神经网络与结构方程模型技术：综述](https://link.springer.com/article/10.1007/s40747-021-00503-w)Hybrid artificial neural network and structural equation modelling techniques: a survey***

## 为什么要结合机器学习（ML）与结构方程模型（SEM）

### ✨ 理论与实践的融合：SEM + ML 的优势

结构方程模型（SEM）是一种强大的因果建模工具，能够同时处理测量模型（潜变量）和路径模型（变量间关系）。但在实际研究中，尤其是面对高维数据(就是变量多)、复杂变量结构或非线性关系时，SEM也面临挑战：

-   **变量筛选困难**：传统SEM依赖理论假设，变量选择主观性强(一般要参考社会科学文献，并且进行假设，麻了)；

-   **模型拟合受限**：当变量数量多、关系复杂时，SEM模型容易过拟合或拟合不佳(过拟合和欠拟合)；

-   **预测能力有限**：SEM更偏向解释性而非预测性。

而机器学习（ML）正好可以补足这些短板：

| 功能       | SEM         | ML                |
|------------|-------------|-------------------|
| 因果推理   | ✅ 强       | ❌ 弱（但可辅助） |
| 潜变量建模 | ✅ 支持     | ❌ 不直接支持     |
| 特征筛选   | ❌ 依赖理论 | ✅ 数据驱动       |
| 非线性建模 | ❌ 有限     | ✅ 强大           |
| 预测能力   | ❌ 弱       | ✅ 强             |

因此，将ML与SEM结合，可以实现：

-   **数据驱动的变量筛选**（如用随机森林或SHAP值找出最重要的预测因子(一般来说如果变量较多的时候，一般是不降维的，而是筛选变量的）；

-   **提升模型解释力与预测力**（先用ML找出**关键变量**，再用SEM建模路径）；

-   **增强模型稳健性**（ML可用于**验证**SEM模型的泛化能力）；

-   **提高研究影响力**（结合方法更前沿，易发表在高影响因子期刊）。

### 📈 文献支持：结合ML与SEM的研究越来越多，影响因子也在上升

以下是提供的几篇代表性文献，展示了ML+SEM的实际应用与发表潜力：

1.  ✅ **复现的论文**： PMC12236327

    -   结合随机森林与SEM，识别影响精神分裂症患者主观幸福感的关键因素。

    -   通过ML筛选变量，再用lavaan构建路径模型，实现因果解释与预测并重。

    -   发表在《Translational Psychiatry》，IF ≈ 7.9。

2.  📱 **智能穿戴设备采纳研究**： Bou Nassif et al. (2022)

    -   使用PLS-SEM与ML对智能手表采纳意图进行建模。

    -   ML揭示“用户满意度”是最关键预测因子，SEM验证其路径关系。

    -   发表在《Heliyon》，IF ≈ 4.0。

3.  🧠 **消费者心理与行为研究**： ScienceDirect 2023论文

    -   用ML筛选影响消费者信任的变量，再用SEM建模信任形成机制。

    -   发表在《Journal of Business Research》，IF ≈ 10.0。

4.  🧬 **健康行为预测研究**： ScienceDirect 2024论文

    -   结合ML与SEM预测健康行为采纳，强调数据驱动与理论建模的融合。

    -   发表在《Preventive Medicine Reports》，IF ≈ 3.5。

------------------------------------------------------------------------

## 什么是机器学习🫤

在正式进入机器学习（Machine Learning, ML）＋结构方程模型（SEM）的整合应用之前，首先要让大家对“机器学习”这个概念有一个直观的理解。不必过分纠结复杂的数学公式，而要抓住它的核心思想和研究流程。

### 2.1 机器学习的定义🤤

机器学习是一种***让计算机通过“样本数据”自行发现规律***，***并将这些规律用于“预测”或“决策”的技术。***\
- 它不像传统统计学那样强调整体假设检验和参数估计，更注重“从数据中自动学习”。\
- ML 旨在用已有数据训练一个模型，让模型在新数据上也能表现出良好的预测或分类能力。

***这也让机器学习无法用数学公式和因果关系来知道电脑是怎么想的，形成了所谓的黑匣子，解释性太差，但是用来预测就没毛病***

### 2.2 ML 与传统统计方法的差异🌮

-   目标不同
    -   统计学：偏重解释性，解析变量间的因果或关联；\
    -   机器学习：偏重预测性，追求模型的泛化能力，即给我数据我可以预测出大概的，符合之前数据的答案。
-   模型假设
    -   统计模型：通常要求满足正态性、线性关系等严格假设；\
    -   ML 模型：对数据分布和关系的假设更弱，***可以处理非线性、高维度数据***。
-   关注点
    -   统计方法：估计参数、显著性检验、置信区间；\
    -   ML 方法：***模型选择、交叉验证、过拟合控制、预测误差***。

### 2.3 机器学习的主要类型🤖

1.  **监督学习（Supervised Learning）**
    -   有“标签”的数据（例如：患者有/无压力性损伤）。\
    -   常见算法：逻辑回归、决策树、随机森林、支持向量机、神经网络等。\
    -   核心任务：分类（Classification）和回归（Regression）。
2.  **无监督学习（Unsupervised Learning）**
    -   无标签数据。\
    -   常见算法：聚类（K-means、层次聚类）、降维（PCA、t-SNE）。\
    -   核心任务：发现数据的内在结构、分群、特征降维。
3.  **强化学习（Reinforcement Learning）**
    -   通过“试错”与环境互动来学习最优策略。\
    -   在护理研究中应用相对少，可用于优化护理路径或资源调度。

### 2.4 机器学习研究流程🛫

1.  **数据准备与清洗**
    -   汇总临床指标、问卷量表、电子健康记录等；\
    -   处理缺失值、异常值、分类变量编码。
2.  **特征工程**
    -   选择或构造与研究目标最相关的变量（特征）即挑选重要的特征变量，过滤不需要的变量；\
    -   归一化、标准化、one-hot 编码(独热编码)等。
3.  **模型训练与优化**
    -   在“训练集”上训练模型；\
    -   通过交叉验证（Cross-Validation）选择超参数，**防止过拟合**(过拟合即是对模型来说，学习太多不重要的特征，比如我训练了一个识别学长还是学姐的模型，但是模型学习到了几个女装的学长，本来女装这是几个人的特殊癖好，但是模型认为女装的都是学长，这扯不扯）。
4.  **模型评估**
    -   ***在“测试集”或“留出数据”上评估预测性能***，这也是为什么机器学习都要分成训练集和验证集，要么7/3,要么8/2等等（千万别耍小聪明，觉得数据不够多，还要拆分，耍滑头把所有数据都拿去训练，然后再拿其中一部分来预测，因为模型有记忆的，你预测训练过的数据，肯定准确率是百分百，就好像你明明知道明天的天气，那为什么要根据之前的数据推测呢）（如 AUC、准确率、RMSE）；\
    -   比较不同算法的优劣。
5.  **模型解释与应用**
    -   使用 SHAP、LIME 等方法**解释模型**

        它们是两种常用的“模型解释工具”，可以告诉我们：**哪些变量对模型预测最重要，以及它们的影响方向**

------------------------------------------------------------------------

# 复现一篇论文🤖

**`最好学习的方法就是看相关论文，然后学习论文知识，然后复现学习，所以啥也不说了，直接真刀真枪开干就完了`**

#### Replicating Research on Subjective Well-Being in Schizophrenia: A Guide to Generating Synthetic Data for SEM and Machine Learning 精神分裂症患者主观幸福感研究：SEM 和机器学习合成数据生成指南

#### [论文链接](https://pmc.ncbi.nlm.nih.gov/articles/PMC12236327/#s5) 2024 Sep 7 ; 51(4):1118–1133. doi: 10.1093/schbul/sbae156 - IF=7.9(我也不知道为什么这种文章有7分，做生信累死累活还拿不到5分，吐槽一下，麻了🥶）

***！现在我不以社会科学的角度解析这篇文章，只用统计学和代码来解析如何处理***

因为我现在没有相关的数据，所以我只能用代码模拟和文章差不多的数据

-   **表 1：机器学习模型中包含的独立变量列表：** 该表概述了分析中使用的所有变量，包括社会人口因素（年龄、性别、教育、职业）、疾病相关因素（疾病持续时间）和各种临床测量。

-   **表 2：样本特征：**提供了 637 名患者原始数据集中变量的描述性统计数据。它包括连续变量的平均值、标准差和范围，以及分类变量的频率。

-   **图 3：网络模型和中心性指标：**展示了不同变量之间的相关性。连接及其粗细表示关系的强度，这应该反映在合成数据的相关矩阵中。

-   **图 4：结构方程模型（SEM）分析：** 该图比网络分析更进一步，揭示了变量之间的因果路径和效应方向。路径系数量化了这些关系的强度和方向。

#### 使用 Python 生成合成数据

以下 Python 代码演示了如何生成一个与论文中描述的特征近似的合成数据集。此代码使用 numpy 和 pandas 库创建一个数据框，其中包含与原始研究中的变量具有相似统计特性和相关性的变量。变量不用Chinese

```{python}
#| echo: true
# 导入所需的库
# 导入所需的库
import numpy as np
import pandas as pd
from scipy.stats import truncnorm

# --- 1. 定义样本量 ---
n_patients = 637

# --- 2. 基于SEM和网络分析生成核心相关数据 ---
correlation_matrix = np.array([
    # SWB,   OCS,   Som,   Cog,   Dep,   Neg,   Pos,   PSP
    [1.00, -0.59, -0.40, -0.20, -0.35, -0.25, -0.15,  0.30],
    [-0.59,  1.00,  0.70,  0.30,  0.40,  0.20,  0.18, -0.25],
    [-0.40,  0.70,  1.00,  0.25,  0.35,  0.15,  0.10, -0.20],
    [-0.20,  0.30,  0.25,  1.00,  0.26,  0.48,  0.36, -0.40],
    [-0.35,  0.40,  0.35,  0.26,  1.00,  0.35,  0.24, -0.50],
    [-0.25,  0.20,  0.15,  0.48,  0.35,  1.00,  0.22, -0.60],
    [-0.15,  0.18,  0.10,  0.36,  0.24,  0.22,  1.00, -0.30],
    [ 0.30, -0.25, -0.20, -0.40, -0.50, -0.60, -0.30,  1.00]
])

mean = np.zeros(correlation_matrix.shape[0])
np.random.seed(42)
correlated_data = np.random.multivariate_normal(mean, correlation_matrix, size=n_patients)

# --- 3. 缩放和转换数据以匹配论文表2中的统计特征 ---

def scale_variable(data_column, mean, std, min_val, max_val):
    scaled = data_column * std + mean
    return np.clip(scaled, min_val, max_val)

cgi_pos = scale_variable(correlated_data[:, 6], 3.7, 1.4, 1, 7)
cgi_neg = scale_variable(correlated_data[:, 5], 3.3, 1.2, 1, 7)
cgi_dep = scale_variable(correlated_data[:, 4], 2.6, 1.2, 1, 6)
cgi_cog = scale_variable(correlated_data[:, 3], 3.1, 1.1, 1, 6)
scl_som = scale_variable(correlated_data[:, 2], 21.3, 8.7, 12, 58)
scl_ocs = scale_variable(correlated_data[:, 1], 22.4, 8.3, 10, 50)
swn_total = scale_variable(correlated_data[:, 0], 73.5, 17.6, 24, 120)
psp_total = scale_variable(correlated_data[:, 7], 55.9, 14.8, 10, 90)
diepss_severity = np.random.uniform(0, 4, n_patients)
diepss_severity = np.clip(diepss_severity, 0, 4)
diepss_severity_mean = np.mean(diepss_severity)
diepss_severity = (diepss_severity - diepss_severity_mean) * (0.8 / np.std(diepss_severity)) + 0.6
diepss_severity = np.clip(diepss_severity, 0, 4)

# --- 4. 生成社会人口统计学及其他变量 ---

age_mean, age_std, age_min, age_max = 35.7, 10.5, 18, 64
age = truncnorm.rvs((age_min - age_mean) / age_std, (age_max - age_mean) / age_std, loc=age_mean, scale=age_std, size=n_patients)
sex = np.random.choice([1, 0], size=n_patients, p=[0.529, 0.471])
education = np.random.choice(['Less than 12 years', 'High school', 'College or graduate'], size=n_patients, p=[0.171, 0.413, 0.416])
occupation = np.random.choice([1, 0], size=n_patients, p=[0.174, 0.826])
illness_duration_mean, illness_duration_std, illness_duration_min, illness_duration_max = 9.1, 8.1, 0, 44
illness_duration = truncnorm.rvs((illness_duration_min - illness_duration_mean) / illness_duration_std, (illness_duration_max - illness_duration_mean) / illness_duration_std, loc=illness_duration_mean, scale=illness_duration_std, size=n_patients)
obesity = np.random.choice([1, 0], size=n_patients, p=[0.468, 0.532])
hypertension = np.random.choice([1, 0], size=n_patients, p=[0.273, 0.727])
diabetes = np.random.choice([1, 0], size=n_patients, p=[0.154, 0.846])

# --- 5. 组合成 Pandas DataFrame ---
synthetic_df = pd.DataFrame({
    'Age': age.round(1),
    'Sex_Female': sex,
    'Education': education,
    'Occupation_Employed': occupation,
    'Duration_of_Illness': illness_duration.round(1),
    'Obesity': obesity,
    'Hypertension': hypertension,
    'Diabetes': diabetes,
    'CGI_Positive': cgi_pos.round(1),
    'CGI_Negative': cgi_neg.round(1),
    'CGI_Depressive': cgi_dep.round(1),
    'CGI_Cognitive': cgi_cog.round(1),
    'SCL90R_Somatization': scl_som.round(1),
    'SCL90R_OCS': scl_ocs.round(1),
    'SWN_Total_Score': swn_total.round(1),
    'DIEPSS_Overall_Severity': diepss_severity.round(1),
    'PSP_Total_Score': psp_total.round(1)
})

# --- 6. 将数据框 (DataFrame) 保存为 CSV 文件 ---
# !!! 重要提示: 请将下面的路径修改为您希望保存文件的实际位置 !!!
# 例如 Windows: "C:/Users/用户名/Documents/synthetic_data.csv"
# 例如 macOS: "/Users/用户名/Documents/synthetic_data.csv"
file_path = "./synthetic_schizophrenia_data.csv"

# 使用 to_csv() 函数来保存数据
# 参数 index=False 的意思是，数据框的行索引 (0, 1, 2, ...) 不会被写入到 CSV 文件中
synthetic_df.to_csv(file_path, index=False)

print(synthetic_df.head(10))

```

### 🧮 数据维度

-   **样本数（行数）**：`637` 由 `n_patients = 637` 指定，模拟的是637位精神分裂症患者的临床与人口学数据。

-   **变量数（列数）**：`17` 包括临床症状、人口学特征、功能状态和代谢指标等变量。

### 📊 变量列表与类型

| 变量名                    | 类型     | 描述                        |
|---------------------------|----------|-----------------------------|
| `Age`                     | 连续变量 | 年龄（18–64岁）             |
| `Sex_Female`              | 二元变量 | 性别（1=女性，0=男性）      |
| `Education`               | 分类变量 | 教育水平（3类）             |
| `Occupation_Employed`     | 二元变量 | 是否就业（1=在职）          |
| `Duration_of_Illness`     | 连续变量 | 病程（0–44年）              |
| `Obesity`                 | 二元变量 | 是否肥胖                    |
| `Hypertension`            | 二元变量 | 是否高血压                  |
| `Diabetes`                | 二元变量 | 是否糖尿病                  |
| `CGI_Positive`            | 连续变量 | 阳性症状评分（1–7）         |
| `CGI_Negative`            | 连续变量 | 阴性症状评分（1–7）         |
| `CGI_Depressive`          | 连续变量 | 抑郁症状评分（1–6）         |
| `CGI_Cognitive`           | 连续变量 | 认知缺陷评分（1–6）         |
| `SCL90R_Somatization`     | 连续变量 | 躯体化评分（12–58）         |
| `SCL90R_OCS`              | 连续变量 | 强迫症状评分（10–50）       |
| `SWN_Total_Score`         | 连续变量 | 主观幸福感评分（24–120）    |
| `DIEPSS_Overall_Severity` | 连续变量 | 锥体外系不良反应评分（0–4） |
| `PSP_Total_Score`         | 连续变量 | 社会功能评分（10–90）       |

### 📊 变量探索(机器学习进行变量的探索，即特征工程)

------------------------------------------------------------------------

**论文的首要分析步骤是利用机器学习 (ML) 来识别决定高水平主观幸福感 (SWB) 的最重要因素。论文作者训练了多个模型，发现随机森林 (RF) 模型表现最佳**

1.  准备机器学习的数据 。

2.  训练随机森林模型来预测哪些患者具有“高水平的 SWB”。

3.  使用 AUC 指标评估模型的性能 ，就像论文中所做的那样。

4.  使用 SHAP 值分析**特征重要性**， 以了解哪些变量是最强大的预测因子，重现论文中图 1B 中的发现。

#### 第一步导入需要的包🧉

-   包是可以认为是游戏的mod,都是大佬收集的算法或者其他的代码来实现你需要的功能，这些都是地基

```{python}
#| echo: true
# 导入所需的库
import pandas as pd                 # 导入 pandas 用于读取和处理数据
import numpy as np                  # 导入 numpy 用于数值计算
from sklearn.model_selection import train_test_split # 导入 train_test_split 用于划分训练集和测试集
from sklearn.ensemble import RandomForestClassifier  # 导入随机森林分类器
from sklearn.metrics import roc_auc_score, roc_curve # 导入评估指标计算函数
import matplotlib.pyplot as plt     # 导入 matplotlib 用于绘图
import shap                         # 导入 SHAP 库用于模型解释
```

#### 第二步导入数据🤤

就是我们要的数据，即调查的数据，一般是XLSX(excel表格)，csv(数据格式万金油)，或者其他格式

```{python}
#| echo: true

# --- 1. 加载并准备数据 ---
# Load and Prepare the Data

# !!! 重要提示: 请将下面的路径修改为您保存 CSV 文件的实际位置 !!!
# For example: "C:/Users/YourUsername/Documents/synthetic_schizophrenia_data.csv"
file_path = "./synthetic_schizophrenia_data.csv"

# 读取我们之前生成的合成数据
df = pd.read_csv(file_path)
```

#### 第三步 定义目标变量和特征变量🥶

我们必须要知道what the fuck is our 目标变量，即我们要研究的目标，这篇文章研究的是 **高水平主观幸福感 (SWB)**，他们想要知道什么因素影响这个鬼东西，而这些因素，比如年龄，身高，体重就是特征变量

-   **定义目标**： 本文机器学习模型的主要目标并非预测准确的主观幸福感 (SWB) 评分，而是将患者分为两组：具有“高水平 SWB”的患者和不具有“高水平 SWB”的患者。我们遵循本文的思路，创建了一个二元目标变量 ( High_SWB )，其中 80 分及以上被视为“高”（编码为 1），低于 80 分则被视为“低”（编码为 0）。

```{python}
#| echo: true

# 定义目标变量 (Y)
# 根据论文，"高水平SWB" 定义为 SWN 总分达到或超过 80
# 我们创建一个名为 'High_SWB' 的新列，1 表示高SWB，0 表示非高SWB
df['High_SWB'] = (df['SWN_Total_Score'] >= 80).astype(int)

# 定义特征变量 (X)
# X 是除了目标变量和原始SWN分数之外的所有列
# We drop the original score and the target variable to create our feature set
X = df.drop(['SWN_Total_Score', 'High_SWB'], axis=1)
y = df['High_SWB']
```

#### 特征工程

特征工程是指从原始数据中提取有用的特征，以便于机器学习模型的训练和预测。

特征工程包括以下几个方面：

1.  特征选择：选择最相关的特征，以减少模型的复杂度，提高模型的泛化能力。即有的时候特征太多，且其中有无意义或者不重要的特征，这时候就需要选择最相关的特征，以减少模型的复杂度，提高模型的泛化能力。
2.  特征提取：从原始数据中提取有用的特征，以便于机器学习模型的训练和预测。
3.  特征变换：对特征进行变换，以便于机器学习模型的训练和预测。比如标准化，归一化，独热编码，等等。 对于一些其他数据类型，比如字符型，如是否为男或者女性，一般可以用1代表男，0代表女，因为模型一般无法了解字的真实含义，但是数字可以。 一般来说，对于特征工程这个步骤需要花费很多时间。我们这个例子的数据比较符合机器学习的类型，不需要太多更改

独热编码是将分类变量转换为二进制变量，即将每个分类变量转换为多个二进制变量，每个二进制变量表示一个分类。比如这个例子教育是分为三类，且都为字符型，我们可以把教育分为三个二进制（0/1）变量，每个二进制变量表示一个分类。

```{python}
#| echo: true

# 处理分类变量
# 'Education' 列是文本类型，机器学习模型需要数值输入。
# 我们使用 "独热编码" (One-Hot Encoding) 将其转换为数值列。
# This converts the 'Education' column into multiple binary (0/1) columns.
X = pd.get_dummies(X, columns=['Education'], drop_first=True)

```

接下来我们要进行数据标准化，他的统计学意义我就不说了，但是为什么要进行标准化，标准化可以会将所有特征缩放到均值为0，标准差为1的范围，对于逻辑回归等线性模型很重要，而对于一些随机森林，神经网络等等的黑箱模型不太重要，但是我还是进行标准化。

```{python}
#| echo: true
# 数据标准化 (对于逻辑回归等线性模型很重要)
# StandardScaler 会将所有特征缩放到均值为0，标准差为1的范围
#先导入我们需要的包
from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
```

\#### 机器学习 我们先定义一堆我们要用的机械学习的模型，论文里面用的是随机森林，逻辑回归，支持向量机，等等

我们将使用五种机器学习模型来预测患者是否具有高水平的主观幸福感（SWB）。每种模型都有不同的特点和适用场景。

##### 1️⃣ Logistic Regression (LR)

. 逻辑回归是一种经典的线性模型，适用于二分类问题（如：高SWB vs 低SWB）。

. 优点：简单、易解释、计算快。

. 原理：根据每个变量的权重，计算一个概率值（0到1之间），判断属于哪个类别。

. 适用场景：变量之间关系较简单、线性时效果好。

2️⃣ Random Forest (RF) . 随机森林是一种集成学习方法，由多个决策树组成。

. 优点：抗过拟合、能处理非线性关系、对缺失值和异常值鲁棒。

. 原理：每棵树都在不同的数据子集上训练，最终通过“投票”决定预测结果。

. 适用场景：变量多、关系复杂时表现优异。

. 3️⃣ Gradient Boosting Machine (GBM) 梯度提升机是一种逐步优化的集成方法。

. 优点：预测精度高，适合复杂数据结构。

. 原理：每棵新树都专注于纠正前一棵树的错误，逐步提升整体性能。

. 适用场景：需要高精度预测时，GBM是常用选择。

.

4️⃣ XGBoost (XGB) . 极端梯度提升是GBM的高效版本，在数据科学竞赛中非常流行。

. 优点：速度快、性能强、支持缺失值处理和正则化。

. 原理：在GBM基础上加入更多优化策略，如剪枝、并行计算。

. 适用场景：大数据、高维度、需要快速训练时。

5️⃣ LightGBM (LGBM) . 轻量级梯度提升机是另一种高效的GBM变体，专为大规模数据设计。

. 优点：训练速度快、内存占用低、适合高维稀疏数据。

. 原理：使用“叶子优先”策略构建树，提升效率。

. 适用场景：数据量大、变量多时非常适合。

**当然，随着现在算法的升级，还有很多算法在他们之上有更好的表现，也要根据数据和模型的用途进行匹配**

📊 为什么要比较多个模型？ 不同模型对数据的敏感性不同，适合的场景也不同。

比较多个模型可以找到最稳定、最准确的预测方法。

```{python}
#| echo: true

#  定义要比较的模型 ---
# 依旧导入需要的包
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
import xgboost as xgb
import lightgbm as lgb

# 我们将所有模型储存在一个字典中，方便循环调用
models = {
    "Logistic Regression (LR)": LogisticRegression(max_iter=1000, random_state=42),
    "Random Forest (RF)": RandomForestClassifier(n_estimators=500, max_depth=5, random_state=42, n_jobs=-1),
    "Gradient Boosting (GBM)": GradientBoostingClassifier(n_estimators=200, max_depth=3, random_state=42),
    "XGBoost (XGB)": xgb.XGBClassifier(n_estimators=200, max_depth=3, use_label_encoder=False, eval_metric='logloss', random_state=42),
    "LightGBM (LGBM)": lgb.LGBMClassifier(n_estimators=200, max_depth=3, random_state=42, verbosity=-1)

}
```

##### 🧪 使用 5 折交叉验证评估所有模型

在这一部分，我们将对五种机器学习模型进行性能评估，使用的是一种非常稳健的方法：5 折交叉验证（5-fold cross-validation）。

. ✅ 什么是交叉验证？ 交叉验证是一种将数据集分成多个“子集”来训练和测试模型的方法。

. 在 5 折交叉验证中，我们将数据分成 5 份：

. 每次用其中 4 份训练模型，剩下 1 份测试模型。

. 这个过程重复 5 次，每次测试集都不同。

. 最后我们计算 5 次的平均性能指标（如 AUC），得到一个更稳定的评估结果。

. 这种方法比单次训练/测试划分更可靠，能减少“运气好/坏”带来的误差。

. 📊 为什么选择 AUC？ . AUC 是衡量模型区分能力的指标，值越接近 1，模型越好。

```{python}
#| echo: true
from sklearn.model_selection import cross_val_score

results = {} # 创建一个空字典来储存结果

print("正在使用5折交叉验证评估每个模型...")

# 循环遍历我们定义的每个模型
for model_name, model in models.items():
    # 对线性模型（逻辑回归）使用标准化后的数据
    if model_name == "Logistic Regression (LR)":
        X_input = X_scaled
    else: # 对树模型使用原始编码后的数据
        X_input = X

    # 使用 cross_val_score 函数进行5折交叉验证
    # cv=5: 指定了折数
    # scoring='roc_auc': 指定评估指标为 AUC

    cv_scores = cross_val_score(model, X_input, y, cv=5, scoring='roc_auc')

    # 将每个模型的名称和其5次交叉验证的平均分及标准差存入结果字典
    results[model_name] = {
        'mean_auc': np.mean(cv_scores),
        'std_auc': np.std(cv_scores)
    }
    
    # 打印每个模型的评估结果
    print(f"  {model_name}: 平均 AUC = {results[model_name]['mean_auc']:.4f} (标准差 = {results[model_name]['std_auc']:.4f})")
```

这些 LightGBM 的日志信息和警告是模型训练过程中的正常输出，尤其是这句：

> **\[Warning\] No further splits with positive gain, best gain: -inf**

它的意思是：在某一轮训练中，LightGBM 没有找到任何可以继续分裂的节点（即没有“正增益”的分裂点），所以该轮的树构建就提前终止了。这通常是因为：

-   数据已经被很好地拟合；

-   当前参数限制了树的复杂度（如 `max_depth`、`min_data_in_leaf` 等）；

-   或者数据本身不支持进一步分裂（例如样本太少或特征太弱）。

这不是错误，也不会影响模型的正常训练和预测性能。

#### 可视化结果🤨

. 比较平均 AUC 分数： 查看打印的输出和条形图。您将看到五个模型的平均 AUC 分数。 与原始论文一致，您可能会发现所有高级模型（RF，GBM，XGB，LGBM）的表现非常相似，并且明显优于基线 Logistic 回归模型 。

随机森林模型可能仍然略占优势，就像论文中提到的那样，AUC 得分在 0.79-0.80 左右 。这证实了我们之前的发现，但现在的置信度更高了。顶级模型之间性能接近，这是机器学习中一个非常常见且重要的发现。

标准差（误差线）的重要性： 标准差（由条形图上的黑色“误差线”表示）告诉您模型的性能在 5 个不同折叠之间的差异有多大。 标准差越小（误差线越短），效果越好。 这意味着模型稳定，其性能不会严重依赖于训练时所用的特定数据子集。

您可能会注意到基于树的模型具有相对较低的方差，这表明它们很稳定。

```{python}
#| echo: true

# 将结果字典转换为 DataFrame，方便绘图
results_df = pd.DataFrame(results).T.sort_values(by='mean_auc', ascending=False)

plt.figure(figsize=(12, 7))
bars = plt.bar(results_df.index, results_df['mean_auc'], yerr=results_df['std_auc'], capsize=5, color='skyblue')

# 在每个柱状图上显示数值
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2.0, yval + 0.01, f'{yval:.3f}', ha='center', va='bottom')

plt.ylabel('Mean AUC Score ')
plt.xlabel('Machine Learning Models ')
plt.title('Comparison of ML Models using 5-Fold Cross-Validation ')
plt.ylim(0, 1.0) # 设置y轴范围为0到1
plt.xticks(rotation=15) # 旋转x轴标签，防止重叠
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()
```

**🎯 模型表现排名（按 AUC）**

| 模型名称                    | 平均 AUC 分数 |
|-----------------------------|---------------|
| 🥇 **Random Forest (RF)**   | **0.798**     |
| 🥈 Logistic Regression (LR) | 0.792         |
| 🥉 LightGBM (LGBM)          | 0.760         |
| XGBoost (XGB)               | 0.758         |
| Gradient Boosting (GBM)     | 0.757         |

**📌 评估**

> 在这次评估中，**Random Forest** 不仅在平均 AUC 上领先，而且其稳定性也很高（标准差较小）。这说明它在不同数据划分下都能保持良好的预测能力，是一个非常可靠的模型选择。

-   虽然逻辑回归易于解释，但在复杂数据中，集成树模型（如 RF）往往能捕捉更丰富的非线性关系；

-   RF 的优势在于“稳健性”和“泛化能力”，尤其适合临床数据这种变量多、结构复杂的场景；

-   这也验证了原始论文的结论：RF 是预测主观幸福感的首选模型之一。

------------------------------------------------------------------------

## 改进模型🤖🤖

虽然我们的模型AUC有0.8左右，这样的数据已经不错了，如果比较原来的论文[原论文链接](https://pmc.ncbi.nlm.nih.gov/articles/PMC12236327/#s5)

`The random forest (RF) model had the highest area under the curve (AUC) of 0.794 at baseline. Obsessive-compulsive symptoms (OCS) had the most significant impact on high levels of SWB, followed by somatization, cognitive deficits, and depression. The network analysis demonstrated robust connections among the SWB, OCS, and somatization. SEM analysis revealed that OCS exerted the strongest direct effect on SWB, and also an indirect effect via the mediation of depression. Furthermore, the contribution of OCS at baseline to SWB was maintained 6 months later.随机森林 (RF) 模型的基线曲线下面积 (AUC) 最高，为 0.794。强迫症状 (OCS) 对高水平主观幸福感 (SWB) 的影响最为显著，其次是躯体化、认知缺陷和抑郁症。网络分析表明，SWB、OCS 和躯体化之间存在稳态联系。结构方程模型 (SEM) 分析显示，OCS 对 SWB 的直接影响最为显著，并且也通过抑郁症的中介产生间接影响。此外，基线 OCS 对 SWB 的贡献在 6 个月后得以维持。`

看起来确实已经不错了，但是我们还是可以对原来的模型进行改善，这是原论文没有进行的操作，具体有两种方法，在模型不改变的情况下

**特征选择（Feature Selection）** 和 **超参数调整（Hyperparameter Tuning）**

#### 🧠 为什么要进行特征选择？

> **理念：少即是多（Less is More）**

在机器学习中，使用所有变量并不总是最好的选择。有些变量可能：

-   与目标无关（噪声）；

-   与其他变量高度冗余（重复信息）；

-   增加模型复杂度，导致过拟合；

-   降低模型解释性，让临床人员难以理解。

### ✅ 特征选择的好处：

-   **提升模型性能**：去除无关变量后，模型更专注于有效信息；

-   **提高训练速度**：变量少，计算更快；

-   **增强解释性**：更容易向临床人员解释模型决策；

-   **减少过拟合风险**：模型更稳健，泛化能力更强。

#### 🔧 为什么要进行超参数调整？

> **理念：模型的“个性化设置”决定它的表现**

每个机器学习模型都有一些“内部设置”，称为**超参数**（hyperparameters），它们不是从数据中学出来的，而是你提前设定的。

例如：

-   随机森林的 `n_estimators`（树的数量）、`max_depth`（树的最大深度）；

-   XGBoost 的 `learning_rate`（学习率）、`subsample`（样本采样比例）；

-   LightGBM 的 `num_leaves`（叶子数）、`min_data_in_leaf`（每个叶子最少样本数）。

### ✅ 超参数调整的好处：

-   **提升模型性能**：找到最适合当前数据的参数组合；

-   **控制模型复杂度**：防止过拟合或欠拟合；

-   **增强模型稳定性**：提高在不同数据划分下的表现一致性。

### 特征选择🤩

```{python}
#| echo: true

# 导入所需的库
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import cross_val_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
# --- 2. 识别最重要的特征 ---
# Identify the most important features

#和以前一样导入数据
# --- 1. 加载并准备数据 (与之前相同) ---
# Load and Prepare the Data

# !!! 重要提示: 请将下面的路径修改为您保存 CSV 文件的实际位置 !!!
file_path = "./synthetic_schizophrenia_data.csv"
df = pd.read_csv(file_path)

df['High_SWB'] = (df['SWN_Total_Score'] >= 80).astype(int)
X = df.drop(['SWN_Total_Score', 'High_SWB'], axis=1)
y = df['High_SWB']
X = pd.get_dummies(X, columns=['Education'], drop_first=True)




print("--- 方法一: 特征选择 ---")
print("首先，我们训练一个基础模型来获取特征重要性...")

# 训练一个临时的随机森林模型来获取特征重要性排序
temp_rf = RandomForestClassifier(n_estimators=500, max_depth=5, random_state=42, n_jobs=-1)
temp_rf.fit(X, y)

# 创建一个包含特征名称和其重要性分数的 DataFrame
feature_importances = pd.DataFrame({
    'feature': X.columns,
    'importance': temp_rf.feature_importances_
}).sort_values('importance', ascending=False)

# 打印最重要的特征
print("\n根据基础模型得出的特征重要性排序:")
print(feature_importances)
```

#### 📊 删除建议（按重要性断层）

我打算删除的变量，其重要性如下：

| 特征名称                     | 重要性 |
|------------------------------|--------|
| DIEPSS_Overall_Severity      | 0.0267 |
| Obesity                      | 0.0096 |
| Diabetes                     | 0.0076 |
| Occupation_Employed          | 0.0063 |
| Education_High school        | 0.0061 |
| Hypertension                 | 0.0049 |
| Sex_Female                   | 0.0047 |
| Education_Less than 12 years | 0.0043 |

这些变量都和 `Age` 的重要性（0.0408）断层，说明它们可能对模型预测贡献非常有限。

但是考虑到`DIEPSS_Oerall_Severity`对于实际意义的确有影响，且和其后面的也断层了，所以我打算保留

***特征选择不仅是“数学问题”，也是“领域知识问题”。***

所以我们已经选出了***10个贡献比较大的特征***

```{python}
#| echo: true
# 选择最重要的前 10 个特征
N_TOP_FEATURES = 10
top_features = feature_importances['feature'].head(N_TOP_FEATURES).tolist()
print(f"\n我们将选择最重要的 {N_TOP_FEATURES} 个特征进行建模: {top_features}")

# 创建只包含最重要特征的新数据集
X_selected = X[top_features]

# --- 3. 在筛选后的特征上重新评估模型 ---
# Re-evaluate the model on selected features

print("\n使用筛选出的特征进行5折交叉验证...")
# 使用与之前相同的模型配置
model_on_selected_features = RandomForestClassifier(n_estimators=500, max_depth=5, random_state=42, n_jobs=-1)
cv_scores_selected = cross_val_score(model_on_selected_features, X_selected, y, cv=5, scoring='roc_auc', n_jobs=-1)

# 打印结果
mean_auc_selected = np.mean(cv_scores_selected)
print(f"\n使用最重要的 {N_TOP_FEATURES} 个特征, 模型的平均 AUC 分数是: {mean_auc_selected:.4f}")
print(f"原始模型的平均 AUC 分数是: 0.7980 (作为对比)")
```

为了加以区别，我们分别复制代码，选取9个和11个特征进行训练看看有什么区别，即剔除`DIEPSS_Overall_Severity 0.026666` 和加上不太重要的`Obesity 0.009579`的变量

```{python}
#| echo: true
# 选择最重要的前 9 个特征
#剔除DIEPSS_Overall_Severity 0.026666
N_TOP_FEATURES = 9
top_features = feature_importances['feature'].head(N_TOP_FEATURES).tolist()
print(f"\n我们将选择最重要的 {N_TOP_FEATURES} 个特征进行建模: {top_features}")

# 创建只包含最重要特征的新数据集
X_selected = X[top_features]

# --- 3. 在筛选后的特征上重新评估模型 ---
# Re-evaluate the model on selected features

print("\n使用筛选出的特征进行5折交叉验证...")
# 使用与之前相同的模型配置
model_on_selected_features = RandomForestClassifier(n_estimators=500, max_depth=5, random_state=42, n_jobs=-1)
cv_scores_selected = cross_val_score(model_on_selected_features, X_selected, y, cv=5, scoring='roc_auc', n_jobs=-1)

# 打印结果
mean_auc_selected = np.mean(cv_scores_selected)
print(f"\n使用最重要的 {N_TOP_FEATURES} 个特征, 模型的平均 AUC 分数是: {mean_auc_selected:.4f}")
print(f"原始模型的平均 AUC 分数是: 0.7980 (作为对比)")

```

```{python}
#| echo: true
# 选择最重要的前 11 个特征
# 加上不太重要的Obesity 0.009579的变量
N_TOP_FEATURES = 11
top_features = feature_importances['feature'].head(N_TOP_FEATURES).tolist()
print(f"\n我们将选择最重要的 {N_TOP_FEATURES} 个特征进行建模: {top_features}")

# 创建只包含最重要特征的新数据集
X_selected = X[top_features]

# --- 3. 在筛选后的特征上重新评估模型 ---
# Re-evaluate the model on selected features

print("\n使用筛选出的特征进行5折交叉验证...")
# 使用与之前相同的模型配置
model_on_selected_features = RandomForestClassifier(n_estimators=500, max_depth=5, random_state=42, n_jobs=-1)
cv_scores_selected = cross_val_score(model_on_selected_features, X_selected, y, cv=5, scoring='roc_auc', n_jobs=-1)

# 打印结果
mean_auc_selected = np.mean(cv_scores_selected)
print(f"\n使用最重要的 {N_TOP_FEATURES} 个特征, 模型的平均 AUC 分数是: {mean_auc_selected:.4f}")
print(f"原始模型的平均 AUC 分数是: 0.7980 (作为对比)")

```

#### 🎯 教学总结：特征选择的实证价值

| 特征数量                           | 平均 AUC 分数 | 相对表现    |
|------------------------------------|---------------|-------------|
| 原始模型（全部特征）               | 0.7980        | 基准        |
| 最重要的 10 个特征                 | **0.7991**    | ✅ 最佳表现 |
| 最重要的 9 个特征（剔除 DIEPSS）   | 0.7975        | 略低        |
| 最重要的 11 个特征（加入 Obesity） | 0.7974        | 略低        |

#### 🧠 要点一：不是特征越多越好

> 增加变量并不一定提升模型性能，反而可能引入噪声或冗余信息。

-   加入 **Obesity（0.009579）** 后，模型性能略微下降；

-   删除 **DIEPSS（0.026666）** 后，模型也略微下降；

-   说明这两个变量虽然贡献不大，但也不是完全无效，尤其 DIEPSS 可能有一定临床解释价值。

#### 🧠 要点二：找到“最佳变量组合”才是关键

> 10个变量组合的模型表现最好，说明它在信息量与简洁性之间达到了平衡。

-   这个组合既保留了高贡献变量，又避免了低贡献变量的干扰；

-   模型更快、更稳定、更易解释；。

#### 🧠 要点三：进行“变量敏感性分析”

-   逐个添加或剔除变量，观察模型性能变化；

-   结合领域知识判断是否保留某些临床重要但模型贡献较低的变量；

-   用图表展示 AUC 随变量数量变化的趋势，强化“变量选择是策略性决策”的理念。

### 超参数调优🎃

例如，假设 n_estimators=500，max_depth=5，但这些设置可能并非我们特定“赛道”（数据集）的最佳设置。通过系统地尝试这些设置的不同组合，我们可以找到能够实现最佳性能的配置 \#### 先是网格搜索

手动定义一个固定的 param_grid 然后进行“暴力”搜索（Brute-force Search），是超参数调优最基础的方法

```{python}
#| echo: true
# 导入 GridSearchCV
from sklearn.model_selection import GridSearchCV

print("\n\n--- 方法二: 超参数调优 (这可能需要几分钟) ---")

# --- 1. 定义要搜索的超参数网格 ---
# Define the parameter grid to search

# 这是一个我们要测试的超参数组合的 "菜单"
param_grid = {
    'n_estimators': [200, 400, 600],       # 树的数量
    'max_depth': [4, 5, 6, 7],             # 树的最大深度
    'min_samples_leaf': [1, 3, 5],         # 一个叶节点上最少的样本数
    'max_features': ['sqrt', 'log2']       # 每次分裂时考虑的最大特征数
}

# --- 2. 设置并运行 GridSearchCV ---
# Setup and run GridSearchCV

# 初始化我们的基础模型
rf_base = RandomForestClassifier(random_state=42, n_jobs=-1)

# 设置 GridSearchCV
# estimator: 我们要调优的模型
# param_grid: 我们定义的参数网格
# cv=5: 使用5折交叉验证来评估每一种参数组合
# scoring='roc_auc': 我们的评估指标
# n_jobs=-1: 使用所有CPU核心并行计算
grid_search = GridSearchCV(estimator=rf_base, param_grid=param_grid, cv=5, scoring='roc_auc', n_jobs=-1, verbose=1)

# 在完整数据集上运行网格搜索
grid_search.fit(X, y)

# --- 3. 打印最佳结果 ---
# Print the best results

print("\n超参数调优完成!")

# 打印找到的最佳参数组合
print(f"找到的最佳超参数组合 (Best Parameters): \n{grid_search.best_params_}")

# 打印使用最佳参数时，交叉验证得到的最佳AUC分数
print(f"\n使用最佳参数时，模型的最佳平均 AUC 分数是: {grid_search.best_score_:.4f}")

```

使用最佳参数时，模型的最佳平均 AUC 分数是: 0.7997 正如我说，网格搜索是超参数最基础的方法，但它有两个主要缺点：

1.  **维度诅咒 (Curse of Dimensionality):** 当参数和你想尝试的值变多时，组合的数量会呈指数级增长，导致计算成本极高，非常耗时。

2.  **效率低下:** 它会花费大量时间去尝试那些明显不佳的参数组合。

接下来我会用一个更加爽的方法，***即贝叶斯优化***

这是目前最先进和最高效的调优方法之一，它完美地体现了“迭代选择最好”的思想。

**核心思想：**\
贝叶斯优化会建立一个关于“哪个参数组合可能得到更高分数”的概率模型。

1.  它首先尝试几个随机的参数组合。

2.  然后，它根据已有的结果，更新内部的概率模型，预测出“最有希望”提升分数的下一个参数组合。

3.  它会去尝试这个“最有希望”的组合，然后再次更新模型。

4.  这个过程会不断迭代，智能地将搜索资源集中在参数空间中最有潜力的区域。

**打个比方：** 这就像在一个大雾弥漫的山区里找最高峰。你不会在地毯式搜索每一寸土地（网格搜索），而是根据你当前所在位置的高度和坡度，来判断下一步往哪个方向走最有可能登得更高。

**🥸不过需要注意的是，由于是随机组合，每次远行代码得到的最好的结果都不一样，就好像在乌泱泱的大海找最大的船，有的时候你不一定能找到山东舰航母，可能只会找到护卫舰**

```{python}
#| echo: true
# 导入 optuna 库
import optuna
from sklearn.model_selection import cross_val_score

print("\n\n--- 最智能的调优方法二: 贝叶斯优化 (Bayesian Optimization with Optuna) ---")
print("Optuna 会根据历史结果，智能地选择下一次要尝试的超参数...")

# --- 1. 定义一个 "目标函数" (Objective Function) ---
# 这个函数告诉 Optuna 如何评估一组超参数的好坏
def objective(trial):
    # 'trial' 对象用于建议超参数的值
    # Optuna 会智能地决定建议值的范围和具体值
    params = {
        'n_estimators': trial.suggest_int('n_estimators', 200, 800), # 建议一个在 [200, 800] 范围内的整数
        'max_depth': trial.suggest_int('max_depth', 3, 10),
        'min_samples_leaf': trial.suggest_int('min_samples_leaf', 1, 10),
        'max_features': trial.suggest_categorical('max_features', ['sqrt', 'log2']),
    }
    
    # 使用这组参数创建并评估模型
    model = RandomForestClassifier(random_state=42, n_jobs=-1, **params)
    
    # 使用交叉验证来获得稳健的分数
    score = cross_val_score(model, X, y, cv=5, scoring='roc_auc', n_jobs=-1).mean()
    
    # Optuna 的目标是最大化这个返回值
    return score

# --- 2. 创建一个 "研究" (Study) 并开始优化 ---
# direction='maximize': 告诉 Optuna 我们的目标是最大化 objective 函数的返回值
study = optuna.create_study(direction='maximize', study_name='RF_Optimization')

# n_trials=100: 运行100次迭代。Optuna 会在这100次中智能地寻找最优解。
study.optimize(objective, n_trials=100)

# --- 3. 打印最佳结果 ---
print("\n贝叶斯优化完成!")
print(f"迭代次数 (Number of finished trials): {len(study.trials)}")
print(f"找到的最佳超参数组合 (Best Parameters): \n{study.best_params}")
print(f"\n使用最佳参数时，模型的最佳平均 AUC 分数是: {study.best_value:.4f}")

```

使用最佳参数时，模型的最佳平均 AUC 分数是: 0.8042(差不多远行了好几次的最好数据),这是迭代只有100次，但是也可以多迭代，设置到200，500等等，只要你的计算机能抗住。

### 最终优化：结合特征选择与贝叶斯调优🤤

**目标**： 在我们已经验证过的“最佳特征集”（最重要的10个特征）上，使用贝叶斯优化（Optuna）来寻找最优的超参数组合，从而获得理论上性能最好的模型

```{python}
#| echo: true
# 导入所有需要的库
import pandas as pd
import numpy as np
import optuna
from sklearn.model_selection import cross_val_score
from sklearn.ensemble import RandomForestClassifier

# --- 1. 最终步骤一：确定并筛选出最佳特征集 (Top 10) ---
# The first step of our final process: identify and select the best feature set.

# !!! 重要提示: 请将下面的路径修改为您保存 CSV 文件的实际位置 !!!
file_path = "./synthetic_schizophrenia_data.csv"
df = pd.read_csv(file_path)

df['High_SWB'] = (df['SWN_Total_Score'] >= 80).astype(int)
X = df.drop(['SWN_Total_Score', 'High_SWB'], axis=1)
y = df['High_SWB']
X = pd.get_dummies(X, columns=['Education'], drop_first=True)


# 训练一个临时模型来获取特征重要性
temp_rf = RandomForestClassifier(n_estimators=500, max_depth=5, random_state=42, n_jobs=-1)
temp_rf.fit(X, y)

# 获取最重要的10个特征的名称
N_TOP_FEATURES = 10
feature_importances = pd.DataFrame({
    'feature': X.columns,
    'importance': temp_rf.feature_importances_
}).sort_values('importance', ascending=False)
top_10_features = feature_importances['feature'].head(N_TOP_FEATURES).tolist()

# 创建只包含这10个特征的新数据集
X_top10 = X[top_10_features]

print("--- 最终优化流程 ---")
print(f"已成功筛选出最重要的 {N_TOP_FEATURES} 个特征用于最终调优:")
print(top_10_features)


# --- 2. 最终步骤二：在最佳特征集上进行贝叶斯优化 ---
# The second step: run Bayesian Optimization on this optimal feature set.

print("\n现在，我们只在这10个特征上进行贝叶斯优化 (Optuna)...")

# 定义目标函数，与之前类似，但这次使用的是筛选后的数据
def objective_top10(trial):
    # 定义超参数搜索空间
    params = {
        'n_estimators': trial.suggest_int('n_estimators', 200, 800),
        'max_depth': trial.suggest_int('max_depth', 3, 10),
        'min_samples_leaf': trial.suggest_int('min_samples_leaf', 1, 10),
        'max_features': trial.suggest_categorical('max_features', ['sqrt', 'log2']),
    }
    
    model = RandomForestClassifier(random_state=42, n_jobs=-1, **params)
    
    # ！！！ 关键不同点 ！！！
    # 注意：我们在这里使用 X_top10，而不是完整的 X
    # CRITICAL DIFFERENCE: We are using X_top10 here, not the full X.
    score = cross_val_score(model, X_top10, y, cv=5, scoring='roc_auc', n_jobs=-1).mean()
    
    return score

# 创建一个新的 "研究" (Study)
study_top10 = optuna.create_study(direction='maximize', study_name='RF_Top10_Optimization')

# 运行优化，n_trials 可以根据需要调整
study_top10.optimize(objective_top10, n_trials=100)

# --- 3. 打印最终优化结果 ---
# Print the final optimization results

best_params_top10 = study_top10.best_params
best_score_top10 = study_top10.best_value

print("\n在Top 10特征集上的贝叶斯优化完成!")
print(f"找到的最佳超参数组合 (Best Parameters): \n{best_params_top10}")
print(f"\n最终模型的最佳平均 AUC 分数是: {best_score_top10:.4f}")

# --- 4. 训练最终的、最优化的模型 ---
# Train the final, most optimized model

print("\n正在使用找到的最佳特征和最佳超参数来训练最终模型...")
final_model = RandomForestClassifier(random_state=42, n_jobs=-1, **best_params_top10)
final_model.fit(X_top10, y)

print("最终模型训练完成！这个模型是我们整个分析过程的最终成果。")

```

同样运行了好几次，得到了较好的数据，***是最终模型的最佳平均 AUC 分数是: 0.8044***

***AUC 接近 0.805 通常意味着模型已经捕捉到了数据中大部分的可预测结构。这就是我们在机器学习中常说的“性能瓶颈”：再怎么调参、选特征，提升空间已经非常有限，这是我们随机森林的极限了，除非换一个更加适配这个数据的机器学习模型。***

***模型的性能上限，往往不是由算法决定的，而是由数据本身的可预测性决定的。 如果数据中没有更多“可解释的信号”，再复杂的模型也无法凭空创造预测能力。***

#### 1. 概念引入：性能天花板与不可约减误差 (Irreducible Error)🧉

性能天花板（Performance Ceiling）。”

**核心知识点：**\
在机器学习中，一个模型的总误差可以被分解为两部分：

**总误差 = 可约减误差 (Reducible Error) + 不可约减误差 (Irreducible Error)**

-   **可约减误差：** 这是我们可以通过选择更好的模型、做特征工程、调优超参数来减少的部分。我们之前做的所有工作，都是在努力**将这部分误差降到最低**。

-   **不可约减误差：** 这是数据本身固有的、无法被任何模型消除的“噪声”或不确定性。**这个误差决定了我们性能天花板的高度。**

-   **打个比方 (Analogy):**\
    这就像用麦克风录音。我们可以买更好的麦克风、调整录音棚的环境来减少背景噪音（降低**可约减误差**）。但是，声音本身的一些微小颤动、空气中的随机分子运动是无法被消除的（**不可约减误差**）。我们能做的，就是尽可能清晰地捕捉到“信号”，但我们无法消除所有的“噪声”。

#### 教学总结：当我们触及天花板时，该做什么🤖？

这是最关键的教学部分。当模型调优不再有效时，真正的数据科学家会从以下几个方面思考，这也是未来的工作方向：

**路径 A：获取更好的数据 (数据为中心 - The Data-Centric Approach)**\
这是**最重要、最有效**的路径。

-   **行动：** 与领域专家（精神科医生、心理学家）合作，讨论是否可以收集新的、可能与主观幸福感相关的数据。比如，在下一次研究中加入“社会支持量表”、“生活事件记录”等。

-   **结论：** **提升性能天花板的最好方法，是为模型提供更高信噪比、更丰富信息的数据。**

**路径 B：尝试完全不同的模型 (模型为中心 - The Model-Centric Approach)**

-   **行动：** 我们已经证明了随机森林（一种基于决策树的集成模型）的极限。我们可以尝试结构完全不同的模型，比如：

    -   **深度学习/神经网络 (Deep Learning / Neural Networks):** 如果有***足够多的数据***，神经网络能够捕捉到比树模型更高阶、更复杂的非线性关系。

    -   **梯度提升机 (Gradient Boosting Machines):** 我们可以对之前测试过的 XGBoost 或 LightGBM 模型进行同样深入的特征选择和贝叶斯优化，有时它们在特定数据集上的表现会略胜于随机森林。

-   **结论：** 换一个更强大的模型**有可能**会略微提升性能，但这通常是在数据质量已经很好的前提下。如果数据本身信息量有限，换模型也只是“锦上添花”，而不会有质的飞跃。

------------------------------------------------------------------------

## 论文总结🤗

this is what it is 没什么总结的，**我们的机器学习得到了在我们测量的所有事物中，哪些与患者的主观幸福感最密切相关？即 OCS、躯体化、认知和抑郁是最重要的预测因素。我们确定了主要特征**

***`这也是差不多你们要写的论文的机器学习的大概流程`***

-   但是如果看我们的复现论文，他们接下来的步骤是

### Step 1: Network Analysis (网络分析)🫥

**“为什么”（目的）：**\
机器学习告诉我们，强迫症症状、躯体化症状、抑郁症和认知是最重要的预测因素。但它并没有告诉我们它们是如何相互关联的。强迫症症状和躯体化症状是否高度相关？抑郁症是否是连接一切的中心枢纽？

网络分析帮助我们将症状的“生态系统”可视化。它将每个变量（症状、人口统计因素）视为一个“节点”（城市），并将它们之间的相关性视为一条“边”（高速公路）。相关性越强，高速公路就越粗。

论文中的图3）：

-   **社群（群落）：** 他们寻找的是节点之间的连接比与网络其他部分的连接更紧密的集群。在论文中，他们发现了一个关键模式：

    -   **社区 1：** 主观幸福感（SWB）、强迫症

    -   **社区 2：** 精神病症状（阳性、阴性）、认知缺陷和社会心理功能 (PSP) 形成了另一个不同的集群。

    -   幸福感的内在体验与强迫症和躯体系统更密切相关

-   **中心性：** 该指标用于识别网络中最具“影响力”的节点。论文指出， **抑郁症**的“中介中心性”最高。

    -   **这是什么意思？** 这意味着抑郁症是连接两个群体的关键**桥梁** 。要从“精神病症状”群体走向“主观幸福感”群体，通常需要经过“抑郁症”这一环节。这表明抑郁症起着关键的中介作用。

这是一种可视化和探索性的工具。它从我们的机器学习模型中获取重要特征列表，并将其转化为地图。这张地图向我们展示了复杂症状网络的结构和关键因素，这让我们假设抑郁症是一个关键的中介因素。

### Step 2: Structural Equation Modeling (SEM) (结构方程模型)🍔

方向或因果关系。它显示了两座城市之间的高速公路，但没有显示交通走向

看看论文中的图 4。这是他们的 SEM 分析结果。它就像一个流程图，展示了影响力的流动。

-   **直接效应（直接效应）：** 从一个变量到另一个变量的直线箭头。

    -   论文发现， **强迫性行为对主观幸福感（SWB）的直接负面影响最为强烈** （见粗红色箭头，系数为-0.59）。这是论文最重要的发现：高强迫性行为会直接摧毁患者的幸福感。

-   **间接效应：** 至少经过一个其他变量的路径。

    -   论文证实了抑郁症的“桥梁”作用。例如，阴性症状有一个箭头指向抑郁症，抑郁症也有一个箭头指向主观幸福感。这是一条**间接路径** 。这意味着阴性症状部分地通过增加抑郁来恶化主观幸福感 。

    -   OCS 还通过抑郁症对 SWB 产生间接影响 。

SEM 是一种验证性工具，是分析的最终步骤，也是最有力的一步。它超越了“什么是重要的”（ML）和“它们如何关联”（网络分析）的范畴，从而检验了关于“什么导致什么”的特定理论。SEM 结果为本文的主要结论提供了最有力的证据：管理 OCS 对于改善精神分裂症患者的主观幸福感至关重要，这既是因为它强大的直接影响，也是因为它通过抑郁症产生的间接影响。

# 我滴任务完成了🛫